/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { LeBarOverflowChangeDetail } from "./components/le-bar/le-bar";
import { LeMultiOptionSelectDetail, LeOption, LeOptionSelectDetail, LeOptionValue } from "./types/options";
import { LeNavigationItemSelectDetail, LeNavigationItemToggleDetail } from "./components/le-navigation/le-navigation";
import { LeKitMode } from "./global/app";
import { PopupPosition, PopupResult, PopupType } from "./components/le-popup/le-popup";
import { LeSidePanelNarrowBehavior, LeSidePanelSide } from "./components/le-side-panel/le-side-panel";
import { LeSidePanelRequestToggleDetail, LeSidePanelToggleAction } from "./components/le-side-panel-toggle/le-side-panel-toggle";
export { LeBarOverflowChangeDetail } from "./components/le-bar/le-bar";
export { LeMultiOptionSelectDetail, LeOption, LeOptionSelectDetail, LeOptionValue } from "./types/options";
export { LeNavigationItemSelectDetail, LeNavigationItemToggleDetail } from "./components/le-navigation/le-navigation";
export { LeKitMode } from "./global/app";
export { PopupPosition, PopupResult, PopupType } from "./components/le-popup/le-popup";
export { LeSidePanelNarrowBehavior, LeSidePanelSide } from "./components/le-side-panel/le-side-panel";
export { LeSidePanelRequestToggleDetail, LeSidePanelToggleAction } from "./components/le-side-panel-toggle/le-side-panel-toggle";
export namespace Components {
    /**
     * A flexible bar component that handles overflow gracefully.
     * Items are slotted children. The bar measures which items fit on the first
     * row and handles overflow according to the `overflow` prop.
     * @csspart container - The main bar container
     * @csspart item - Individual items in the bar
     * @csspart more-button - The "more" overflow button
     * @csspart hamburger-button - The hamburger menu button
     * @csspart arrow-start - The start (left) scroll arrow
     * @csspart arrow-end - The end (right) scroll arrow
     * @csspart all-menu-button - The "show all" menu button
     * @csspart popover-content - The popover content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBar {
        /**
          * Alignment of items within the bar (maps to justify-content).
          * @default 'start'
         */
        "alignItems": 'start' | 'end' | 'center' | 'stretch';
        /**
          * Show scroll arrows when overflow is "scroll".
          * @default false
         */
        "arrows": boolean;
        /**
          * Disable the internal overflow popover. When true, the bar still detects overflow and hides items, but doesn't render its own popover. Use this when providing custom overflow handling via the leBarOverflowChange event.
          * @default false
         */
        "disablePopover": boolean;
        /**
          * Minimum number of visible items required when using "more" overflow mode. If fewer items would be visible, the bar falls back to hamburger mode. Only applies when overflow is "more".
          * @default 0
         */
        "minVisibleItems": number;
        /**
          * Overflow behavior when items don't fit on one row. - `more`: Overflow items appear in a "more" dropdown - `scroll`: Items scroll horizontally with optional arrows - `hamburger`: All items go into a hamburger menu if any overflow - `wrap`: Items wrap to additional rows
          * @default 'more'
         */
        "overflow": 'more' | 'scroll' | 'hamburger' | 'wrap';
        /**
          * Force recalculation of overflow state.
         */
        "recalculate": () => Promise<void>;
        /**
          * Show an "all items" menu button. - `false`: Don't show - `true` or `'end'`: Show at end - `'start'`: Show at start
          * @default false
         */
        "showAllMenu": boolean | 'start' | 'end';
    }
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBox {
        /**
          * Internal horizontal alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'stretch'
         */
        "alignContent": 'start' | 'center' | 'end' | 'stretch';
        /**
          * Self-alignment override for this item on the cross axis
          * @allowedValues auto | start | center | end | stretch | baseline
          * @default 'auto'
         */
        "alignSelf": 'auto' | 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Background color or CSS value (e.g., '#f0f0f0', 'var(--le-color-primary-light)')
         */
        "background"?: string;
        /**
          * Flex basis - initial size before growing/shrinking (e.g., '200px', '25%', 'auto')
          * @default 'auto'
         */
        "basis": string;
        /**
          * Border style (e.g., '1px solid #ccc', '2px dashed var(--le-color-border)')
         */
        "border"?: string;
        /**
          * Border radius (e.g., '8px', 'var(--le-radius-md)')
         */
        "borderRadius"?: string;
        /**
          * Whether to display box content as flex (for internal alignment)
          * @default false
         */
        "displayFlex": boolean;
        /**
          * Flex grow factor - how much the item should grow relative to siblings
          * @min 0
          * @default 0
         */
        "grow": number;
        /**
          * Height of the box (CSS value)
         */
        "height"?: string;
        /**
          * Direction of internal flex layout when displayFlex is true
          * @allowedValues horizontal | vertical
          * @default 'vertical'
         */
        "innerDirection": 'horizontal' | 'vertical';
        /**
          * Gap between internal flex items when displayFlex is true
         */
        "innerGap"?: string;
        /**
          * Internal vertical alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'start'
         */
        "justifyContent": 'start' | 'center' | 'end' | 'stretch';
        /**
          * Maximum height constraint
         */
        "maxHeight"?: string;
        /**
          * Maximum width constraint
         */
        "maxWidth"?: string;
        /**
          * Minimum height constraint
         */
        "minHeight"?: string;
        /**
          * Minimum width constraint
         */
        "minWidth"?: string;
        /**
          * Order in the flex container (lower values come first)
         */
        "order"?: number;
        /**
          * Padding inside the box (CSS value like '8px', '1rem')
         */
        "padding"?: string;
        /**
          * Flex shrink factor - how much the item should shrink relative to siblings
          * @min 0
          * @default 1
         */
        "shrink": number;
        /**
          * Width of the box (CSS value like '100px', '50%', 'auto')
         */
        "width"?: string;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeButton {
        /**
          * Alignment of the button label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align": 'start' | 'center' | 'space-between' | 'end';
        /**
          * Button color theme (uses theme semantic colors)
          * @allowedValues primary | secondary | success | warning | danger | info
          * @default 'primary'
         */
        "color": 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Whether the button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the button takes full width of its container
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Optional href to make the button act as a link
         */
        "href"?: string;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Icon only button image or emoji if this prop is set, the button will render only the icon slot
         */
        "iconOnly"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * Whether the button is in a selected/active state
          * @default false
         */
        "selected": boolean;
        /**
          * Button size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * The button type attribute
          * @allowedValues button | submit | reset
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * Button variant style
          * @allowedValues solid | outlined | clear
          * @default 'solid'
         */
        "variant": 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCard {
        /**
          * Whether the card is interactive (clickable)
          * @default false
         */
        "interactive": boolean;
        /**
          * Card variant style
          * @allowedValues default | outlined | elevated
          * @default 'default'
         */
        "variant": 'default' | 'outlined' | 'elevated';
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface LeCheckbox {
        /**
          * Whether the checkbox is checked
          * @default false
         */
        "checked": boolean;
        /**
          * Whether the checkbox is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems (e.g. database ID, PDF form field ID)
         */
        "externalId": string;
        /**
          * The name of the checkbox input
         */
        "name": string;
        /**
          * The value of the checkbox input
         */
        "value": string;
    }
    /**
     * A one-time code input component with individual frames for each character.
     * Supports standard copy/paste and range selection behaviors.
     * @cssprop --le-code-box-size - Size of each character box (default: 40px width, 48px height)
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     */
    interface LeCodeInput {
        /**
          * Description text displayed below the input in case there is a more complex markup, it can be provided via slot as well
         */
        "description"?: string;
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Internal validation state (can be set externally manually or via simple check)
          * @default false
         */
        "error": boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId": string;
        /**
          * Label for the input
         */
        "label": string;
        /**
          * Length of the code (number of characters)
          * @default 6
         */
        "length": number;
        /**
          * The name of the input
         */
        "name": string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * The type of code (numeric or alphanumeric) This affects the keyboard layout on mobile devices.
          * @default 'text'
         */
        "type": 'text' | 'number';
        /**
          * The value of the input
          * @default ''
         */
        "value": string;
    }
    /**
     * Animated show/hide wrapper.
     * Supports height collapse (auto->0) and/or fading.
     * Can optionally listen to the nearest `le-header` shrink events.
     * @cssprop --le-collapse-duration - Transition duration
     * @csspart region - Collapsible region
     * @csspart content - Inner content
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCollapse {
        /**
          * Since Stencil boolean props default to `false` when the attribute is missing. instead of `open` defaulting to `true`, using a `closed` prop.
          * @default false
         */
        "closed": boolean;
        /**
          * If true, collapse/expand based on the nearest header shrink event.
          * @default false
         */
        "collapseOnHeaderShrink": boolean;
        /**
          * Stop fading the content when collapsing/expanding.
          * @default false
         */
        "noFading": boolean;
        /**
          * Whether the content should scroll down from the top when open.
          * @default false
         */
        "scrollDown": boolean;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface LeCombobox {
        /**
          * Whether to allow custom values not in the options list.
          * @default false
         */
        "allowCustom": boolean;
        /**
          * Whether the combobox is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Focuses the input element.
         */
        "focusInput": () => Promise<void>;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Minimum characters before showing filtered results.
          * @default 0
         */
        "minSearchLength": number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text for the input.
          * @default 'Type to search...'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Size variant of the combobox.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
    }
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeComponent {
        /**
          * The tag name of the component (e.g., 'le-card'). Used to look up property metadata and display the component name.
         */
        "component": string;
        /**
          * Optional display name for the component. If not provided, the tag name will be formatted as the display name.
         */
        "displayName"?: string;
        /**
          * Classes to apply to the host element. Allows parent components to pass their styling classes.
         */
        "hostClass"?: string;
        /**
          * Inline styles to apply to the host element. Allows parent components to pass dynamic styles (e.g., flex properties).
         */
        "hostStyle"?: { [key: string]: string };
    }
    /**
     * Shows a "smart" header title based on what has scrolled out of view.
     * When `selector` matches multiple elements, the title becomes the last element
     * (top-to-bottom) that has fully scrolled out above the viewport.
     * @csspart title - The rendered title
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCurrentHeading {
        /**
          * CSS selector for page title/headings to watch (e.g. `.page-title`, `main h2`).
          * @default ''
         */
        "selector": string;
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeDropdownBase {
        /**
          * Whether to close the dropdown when clicking outside. (used to support combobox with input focus)
          * @default true
         */
        "closeOnClickOutside": boolean;
        /**
          * Whether the dropdown is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Placeholder text when no options match filter.
          * @default 'No options'
         */
        "emptyText": string;
        /**
          * Filter function for options. Return true to include the option.
         */
        "filterFn"?: (option: LeOption, query: string) => boolean;
        /**
          * Current filter query string.
          * @default ''
         */
        "filterQuery": string;
        /**
          * Sets the dropdown to full width of the trigger.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hide": () => Promise<void>;
        /**
          * Maximum height of the dropdown list.
          * @default '300px'
         */
        "maxHeight": string;
        /**
          * Whether multiple selection is allowed.
          * @default false
         */
        "multiple": boolean;
        /**
          * Whether the dropdown is open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[];
        /**
          * Opens the dropdown.
         */
        "show": () => Promise<void>;
        /**
          * Whether to show checkboxes for multiselect mode.
          * @default true
         */
        "showCheckboxes": boolean;
        /**
          * Toggles the dropdown.
         */
        "toggle": () => Promise<void>;
        /**
          * Current value(s) - single value or array for multiselect.
         */
        "value"?: LeOptionValue | LeOptionValue[];
        /**
          * Width of the dropdown. If not set, matches trigger width.
         */
        "width"?: string;
    }
    /**
     * A functional page header with scroll-aware behaviors.
     * Features:
     * - Static (default), sticky, or fixed positioning
     * - Optional shrink-on-scroll behavior via `shrink-offset`
     * - Optional reveal-on-scroll-up via `reveal-on-scroll` (sticky only)
     * Slots:
     * - `start`: left side (logo/back button)
     * - `title`: centered/primary title content
     * - `end`: right side actions
     * - default: extra content row (e.g., tabs/search) rendered below main row
     * @cssprop --le-header-bg - Background (color/gradient)
     * @cssprop --le-header-color - Text color
     * @cssprop --le-header-border - Border (e.g. 1px solid ...)
     * @cssprop --le-header-shadow - Shadow/elevation
     * @cssprop --le-header-max-width - Inner content max width
     * @cssprop --le-header-padding-x - Horizontal padding
     * @cssprop --le-header-padding-y - Vertical padding
     * @cssprop --le-header-gap - Gap between zones
     * @cssprop --le-header-height - Base height (main row)
     * @cssprop --le-header-height-condensed - Condensed height when shrunk
     * @cssprop --le-header-transition - Transition timing
     * @cssprop --le-header-z - Z-index (fixed mode)
     * @csspart header - The header container
     * @csspart inner - Inner max-width container
     * @csspart row - Main row
     * @csspart start - Start zone
     * @csspart title - Title zone
     * @csspart end - End zone
     * @csspart secondary - Secondary row
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeHeader {
        /**
          * If true, expand the header when hovered
          * @default false
         */
        "expandOnHover": boolean;
        /**
          * Fixed positioning (out-of-flow). Takes precedence over `sticky`/`static`.
          * @default false
         */
        "fixed": boolean;
        /**
          * Force static positioning (default). Ignored if `sticky` or `fixed` are true.
          * @default false
         */
        "isStatic": boolean;
        /**
          * Sticky-only reveal behavior (hide on scroll down, show on scroll up). - missing/false: disabled - true/empty attribute: enabled with default threshold (16) - number (as string): enabled and used as threshold
         */
        "revealOnScroll"?: string;
        /**
          * Shrink trigger. - missing/0: disabled - number (px): shrink when scrollY >= that value (but never before header height) - css var name (e.g. --foo): shrink when scrollY >= resolved var value - selector (e.g. .page-title): shrink when that element scrolls out of view above the viewport
         */
        "shrinkOffset"?: string;
        /**
          * Sticky positioning (in-flow). Ignored if `fixed` is true.
          * @default false
         */
        "sticky": boolean;
    }
    /**
     * Placeholder for `le-header`.
     * Reserves space using the global CSS variable `--le-header-height`.
     * The header component updates that variable when it renders.
     * @cssprop --le-header-height - Published header height (px)
     * @cmsInternal true
     */
    interface LeHeaderPlaceholder {
    }
    interface LeIcon {
        /**
          * Name of the icon to display. Corresponds to a JSON file in the assets folder. For example, "search" will load the "search.json" file.
          * @default null
         */
        "name": string;
        /**
          * Size of the icon in pixels. Default is 16.
          * @default 16
         */
        "size": number;
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface LeMultiselect {
        /**
          * Clears all selections.
         */
        "clearSelection": () => Promise<void>;
        /**
          * Whether the multiselect is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Maximum number of selections allowed.
         */
        "maxSelections"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text when no options are selected.
          * @default 'Select options...'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Whether to show a "Select All" option. Also accepts a string or array of strings to customize the label(s).
          * @default false
         */
        "showSelectAll": boolean | string | string[];
        /**
          * Size variant of the multiselect.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected values.
          * @default []
         */
        "value": LeOptionValue[];
    }
    /**
     * Navigation component with vertical (tree) and horizontal (menu) layouts.
     * - Accepts items as `LeOption[]` or a JSON string.
     * - Supports hierarchical items via `children`.
     * - Supports persisted expansion via `open` on items.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeNavigation {
        /**
          * Active url for automatic selection.
          * @default ''
         */
        "activeUrl": string;
        /**
          * Alignment of the menu items within the navigation bar.
          * @default 'start'
         */
        "align": 'start' | 'end' | 'center' | 'space-between';
        /**
          * Text shown when no items match the filter.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Navigation items. Can be passed as an array or JSON string (same pattern as le-select).
          * @default []
         */
        "items": LeOption[] | string;
        /**
          * Minimum number of visible top-level items required to use the "More" overflow. If fewer would be visible, the navigation falls back to hamburger.
          * @default 2
         */
        "minVisibleItemsForMore": number;
        /**
          * Layout orientation.
          * @default 'horizontal'
         */
        "orientation": 'vertical' | 'horizontal';
        /**
          * Overflow behavior for horizontal, non-wrapping menus. - more: moves overflow items into a "More" popover - hamburger: turns the whole nav into a hamburger popover
          * @default 'more'
         */
        "overflowMode": 'more' | 'hamburger';
        /**
          * Placeholder text for the search input.
          * @default 'Search...'
         */
        "searchPlaceholder": string;
        /**
          * Enables a search input for the vertical navigation.
          * @default false
         */
        "searchable": boolean;
        /**
          * Whether submenu popovers should include a filter input.
          * @default false
         */
        "submenuSearchable": boolean;
        /**
          * Horizontal wrapping behavior. If false, overflow behavior depends on `overflowMode`.
          * @default false
         */
        "wrap": boolean;
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeNumberInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId": string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Label for the input
         */
        "label": string;
        /**
          * Maximum allowed value
         */
        "max"?: number;
        /**
          * Minimum allowed value
         */
        "min"?: number;
        /**
          * The name of the input
         */
        "name": string;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * Whether the input is required
          * @default false
         */
        "required": boolean;
        /**
          * Whether to show the spinner controls
          * @default true
         */
        "showSpinners": boolean;
        /**
          * Step value for increment/decrement
          * @default 1
         */
        "step": number;
        /**
          * The value of the input
         */
        "value": number;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopover {
        /**
          * Alignment of the popover
          * @default 'start'
         */
        "align": 'start' | 'center' | 'end';
        /**
          * Whether clicking outside closes the popover
          * @default true
         */
        "closeOnClickOutside": boolean;
        /**
          * Whether pressing Escape closes the popover
          * @default true
         */
        "closeOnEscape": boolean;
        /**
          * Closes the popover
         */
        "hide": () => Promise<void>;
        /**
          * Maximum width for the popover (e.g., '400px', '25rem')
         */
        "maxWidth"?: string;
        /**
          * Minimum width for the popover (e.g., '200px', '15rem')
          * @default '200px'
         */
        "minWidth"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * Offset from the trigger element (in pixels)
          * @default 8
         */
        "offset": number;
        /**
          * Whether the popover is currently open
          * @default false
         */
        "open": boolean;
        /**
          * Optional title for the popover header
         */
        "popoverTitle"?: string;
        /**
          * Position of the popover relative to its trigger
          * @default 'bottom'
         */
        "position": 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Opens the popover
         */
        "show": () => Promise<void>;
        /**
          * Whether to show a close button in the header
          * @default true
         */
        "showClose": boolean;
        /**
          * Toggles the popover
         */
        "toggle": () => Promise<void>;
        /**
          * Should the popover's trigger take full width of its container
          * @default false
         */
        "triggerFullWidth": boolean;
        /**
          * Method to update the popover position from a parent component
         */
        "updatePosition": () => Promise<void>;
        /**
          * Fixed width for the popover (e.g., '300px', '20rem')
         */
        "width"?: string;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopup {
        /**
          * Text for the cancel button
          * @default 'Cancel'
         */
        "cancelText": string;
        /**
          * Whether clicking the backdrop closes the popup (modal only)
          * @default true
         */
        "closeOnBackdrop": boolean;
        /**
          * Text for the confirm/OK button
          * @default 'OK'
         */
        "confirmText": string;
        /**
          * Default value for prompt input
          * @default ''
         */
        "defaultValue": string;
        /**
          * Closes the popup with a result
         */
        "hide": (confirmed?: boolean) => Promise<void>;
        /**
          * Message text to display (for alert/confirm/prompt types)
         */
        "message"?: string;
        /**
          * Whether the popup is modal (blocks interaction with page behind)
          * @default true
         */
        "modal": boolean;
        /**
          * The mode of the Le Kit (e.g., 'default' or 'admin')
          * @default 'default'
         */
        "mode": LeKitMode;
        /**
          * Whether the popup is currently visible
          * @default false
         */
        "open": boolean;
        /**
          * Placeholder text for prompt input
          * @default ''
         */
        "placeholder": string;
        /**
          * Optional title for the popup header
         */
        "popupTitle"?: string;
        /**
          * Position of the popup on screen
          * @default 'center'
         */
        "position": PopupPosition;
        /**
          * Opens the popup and returns a promise that resolves when closed
         */
        "show": () => Promise<PopupResult>;
        /**
          * Type of popup: alert (OK only), confirm (OK/Cancel), prompt (input + OK/Cancel), custom
          * @default 'alert'
         */
        "type": PopupType;
    }
    interface LeRoundProgress {
        /**
          * @default 0
         */
        "padding": number;
        "paths": string;
        /**
          * @default 0
         */
        "value": number;
    }
    /**
     * Displays scroll progress as a simple bar.
     * If `track-scroll-progress` is present without a value, tracks the full document.
     * If it is a selector string, tracks progress within the matched element.
     * @cssprop --le-scroll-progress-height - Bar height
     * @cssprop --le-scroll-progress-bg - Track background
     * @cssprop --le-scroll-progress-fill - Fill color
     * @cssprop --le-scroll-progress-sticky-top - If sticky, stop position to parent top
     * @cssprop --le-scroll-progress-fixed-top - If fixed, distance from window top
     * @cssprop --le-scroll-progress-fixed-left - If fixed, distance from window left
     * @cssprop --le-scroll-progress-fixed-right - If fixed, distance from window right
     * @cssprop --le-scroll-progress-z - Z-index of the progress bar (1001 by default, above header)
     * @csspart track - Outer track
     * @csspart fill - Inner fill
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeScrollProgress {
        /**
          * Boolean or selector string.
         */
        "trackScrollProgress"?: string;
    }
    /**
     * A segmented control component (iOS-style toggle buttons).
     * Perfect for toggling between a small set of related options.
     * @cssprop --le-segmented-bg - Background color of the control
     * @cssprop --le-segmented-padding - Padding around segments
     * @cssprop --le-segmented-gap - Gap between segments
     * @cssprop --le-segmented-radius - Border radius of the control
     * @csspart container - The main container
     * @csspart segment - Individual segment buttons
     * @csspart segment-active - The currently active segment
     * @cmsEditable true
     * @cmsCategory Form
     */
    interface LeSegmentedControl {
        /**
          * Whether the control is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the control should take full width.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Array of options for the segmented control.
          * @default []
         */
        "options": LeOption[];
        /**
          * Scroll behavior for overflowing tabs.
          * @allowedValues auto | hidden | visible | scroll
          * @default 'auto'
         */
        "overflow": 'auto' | 'hidden' | 'visible' | 'scroll';
        /**
          * Size of the control.
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The value of the currently selected option.
         */
        "value"?: LeOptionValue;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface LeSelect {
        /**
          * Whether the select is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Whether the select should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text when no option is selected.
          * @default 'Select an option'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Size variant of the select.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
        /**
          * Visual variant of the select.
          * @default 'default'
         */
        "variant": 'default' | 'outlined' | 'solid';
    }
    interface LeSidePanel {
        /**
          * When crossing to narrow mode, automatically hide the panel (open=false).
          * @default true
         */
        "autoHideOnNarrow": boolean;
        /**
          * When crossing to wide mode, automatically show the panel (collapsed=false).
          * @default true
         */
        "autoShowOnWide": boolean;
        /**
          * Width breakpoint (in px or a CSS var like `--le-breakpoint-md`) below which the panel enters "narrow" mode.
         */
        "collapseAt"?: string;
        /**
          * Panel collapsed state for wide mode (fully hidden).
          * @default false
         */
        "collapsed": boolean;
        /**
          * Maximum allowed width when resizable.
          * @default 420
         */
        "maxPanelWidth": number;
        /**
          * Minimum allowed width when resizable.
          * @default 220
         */
        "minPanelWidth": number;
        /**
          * Behavior when in narrow mode.
          * @default 'overlay'
         */
        "narrowBehavior": LeSidePanelNarrowBehavior;
        /**
          * Panel open state for narrow mode. - overlay: controls modal drawer visibility - push: controls whether panel is shown (non-modal)
          * @default false
         */
        "open": boolean;
        /**
          * Optional id used to match toggle requests. If set, the panel only responds to toggle events with the same `panelId`.
         */
        "panelId"?: string;
        /**
          * Accessible label for the panel navigation region.
          * @default 'Navigation'
         */
        "panelLabel": string;
        /**
          * Default panel width in pixels.
          * @default 280
         */
        "panelWidth": number;
        /**
          * When set, panel width + collapsed state are persisted in localStorage.
         */
        "persistKey"?: string;
        /**
          * Allows users to resize the panel by dragging its edge.
          * @default false
         */
        "resizable": boolean;
        /**
          * Show a close button inside the panel (primarily used in narrow overlay mode).
          * @default true
         */
        "showCloseButton": boolean;
        /**
          * Which side the panel is attached to.
          * @default 'start'
         */
        "side": LeSidePanelSide;
    }
    interface LeSidePanelToggle {
        /**
          * Action to emit. Default toggles the panel.
          * @default 'toggle'
         */
        "action": LeSidePanelToggleAction;
        /**
          * @default 'center'
         */
        "align": 'start' | 'center' | 'space-between' | 'end';
        /**
          * @default 'primary'
         */
        "color": 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Disables the toggle.
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "fullWidth": boolean;
        "href"?: string;
        "iconEnd"?: string | Node;
        "iconOnly"?: string | Node;
        "iconStart"?: string | Node;
        "mode": 'default' | 'admin';
        /**
          * Optional id used to target a specific panel.
         */
        "panelId"?: string;
        /**
          * @default false
         */
        "selected": boolean;
        /**
          * Optional keyboard shortcut like `Mod+B` or `Alt+N`.
         */
        "shortcut"?: string;
        /**
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        "target"?: string;
        /**
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * @default 'solid'
         */
        "variant": 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeSlot {
        /**
          * Comma-separated list of allowed component tags for this slot. Used by CMS to filter available components.
          * @example "le-card,le-button,le-text"
         */
        "allowedComponents"?: string;
        /**
          * Description of what content this slot accepts. Shown in admin mode to guide content editors.
         */
        "description"?: string;
        /**
          * Label to display in admin mode. If not provided, the slot name will be used.
         */
        "label"?: string;
        /**
          * Whether multiple components can be dropped in this slot.
          * @default true
         */
        "multiple": boolean;
        /**
          * The name of the slot this placeholder represents. Should match the slot name in the parent component.
          * @default ''
         */
        "name": string;
        /**
          * Placeholder text for text/textarea inputs in admin mode.
         */
        "placeholder"?: string;
        /**
          * Whether this slot is required to have content.
          * @default false
         */
        "required": boolean;
        /**
          * CSS styles for the slot dropzone container. Useful for layouts - e.g., "flex-direction: row" for horizontal stacks. Only applies in admin mode for type="slot".
         */
        "slotStyle"?: string;
        /**
          * The HTML tag to create when there's no slotted element. Used with type="text" or type="textarea" to auto-create elements.
          * @example "h3" - creates <h3 slot="header">content</h3>
          * @example "p" - creates <p slot="content">content</p>
         */
        "tag"?: string;
        /**
          * The type of slot content. - `slot`: Default, shows a dropzone for components (default) - `text`: Shows a single-line text input - `textarea`: Shows a multi-line text area
          * @default 'slot'
         */
        "type": 'slot' | 'text' | 'textarea';
    }
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeStack {
        /**
          * Alignment of items on the cross axis
          * @allowedValues start | center | end | stretch | baseline
          * @default 'stretch'
         */
        "align": 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Alignment of wrapped lines (only applies when wrap is true)
          * @allowedValues start | center | end | stretch | space-between | space-around
          * @default 'stretch'
         */
        "alignContent": 'start' | 'center' | 'end' | 'stretch' | 'space-between' | 'space-around';
        /**
          * Direction of the stack layout
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "direction": 'horizontal' | 'vertical';
        /**
          * Whether the stack should take full height of its container
          * @default false
         */
        "fullHeight": boolean;
        /**
          * Whether the stack should take full width of its container
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Gap between items (CSS value like '8px', '1rem', 'var(--le-space-md)')
         */
        "gap"?: string;
        /**
          * Distribution of items on the main axis
          * @allowedValues start | center | end | space-between | space-around | space-evenly
          * @default 'start'
         */
        "justify": 'start' | 'center' | 'end' | 'space-between' | 'space-around' | 'space-evenly';
        /**
          * Maximum number of items allowed in the stack (for CMS validation)
          * @min 1
         */
        "maxItems"?: number;
        /**
          * Padding inside the stack container (CSS value)
         */
        "padding"?: string;
        /**
          * Whether to reverse the order of items
          * @default false
         */
        "reverse": boolean;
        /**
          * Whether items should wrap to multiple lines
          * @default false
         */
        "wrap": boolean;
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeStringInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId": string;
        /**
          * Hide description slot
          * @default false
         */
        "hideDescription": boolean;
        /**
          * Icon for the end icon
         */
        "iconEnd": string;
        /**
          * Icon for the start icon
         */
        "iconStart": string;
        /**
          * Pass the ref of the input element to the parent component
         */
        "inputRef"?: (el: HTMLInputElement) => void;
        /**
          * Label for the input
         */
        "label": string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * The name of the input
         */
        "name": string;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * The type of the input (text, email, password, etc.)
          * @default 'text'
         */
        "type": 'text' | 'email' | 'password' | 'tel' | 'url';
        /**
          * The value of the input
         */
        "value": string;
    }
    /**
     * A flexible tab component with multiple variants and states.
     * @cssprop --le-tab-bg - Tab background color
     * @cssprop --le-tab-color - Tab text color
     * @cssprop --le-tab-border-radius - Tab border radius
     * @cssprop --le-tab-padding-x - Tab horizontal padding
     * @cssprop --le-tab-padding-y - Tab vertical padding
     * @csspart button - The native button element
     * @csspart content - The tab content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeTab {
        /**
          * Alignment of the tab label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align": 'start' | 'center' | 'space-between' | 'end';
        /**
          * Whether the tab is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the tab can get focus needed for accessibility when used in custom tab implementations
          * @default true
         */
        "focusable": boolean;
        /**
          * Whether the tab takes full width of its container
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Get tab configuration for parent component
         */
        "getTabConfig": () => Promise<{ label: string; value: string; icon: string | Node; iconStart?: string | Node; iconEnd?: string | Node; disabled: boolean; }>;
        /**
          * Optional href to make the tab act as a link
         */
        "href"?: string;
        /**
          * Icon only tab image or emoji if this prop is set, the tab will render only the icon slot
         */
        "icon"?: string | Node;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Label if it is not provided via slot
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * Position of the tabs when used within a le-tabs component
          * @allowedValues top | bottom | start | end
          * @default 'top'
         */
        "position": 'top' | 'bottom' | 'start' | 'end';
        /**
          * Whether the tab is in a selected/active state
          * @default false
         */
        "selected": boolean;
        /**
          * Whether to show the label when in icon-only mode
          * @default false
         */
        "showLabel": boolean;
        /**
          * Tab size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * Value of the tab, defaults to label if not provided
         */
        "value"?: string;
        /**
          * Tab variant style
          * @allowedValues solid | underlined | clear | enclosed | icon-only
          * @default 'underlined'
         */
        "variant": 'underlined' | 'solid' | 'pills' | 'enclosed' | 'icon-only';
    }
    /**
     * A presentational tab bar component without panels.
     * Use this for navigation/routing scenarios where you manage the content
     * externally based on the selection events. For tabs with built-in panels,
     * use `le-tabs` instead.
     * @cssprop --le-tab-bar-border-color - Border color
     * @cssprop --le-tab-bar-gap - Gap between tabs
     * @cssprop --le-tab-bar-indicator-color - Active indicator color
     * @cssprop --le-tab-bar-padding-x - Horizontal padding for tabs
     * @cssprop --le-tab-bar-padding-y - Vertical padding for tabs
     * @csspart tablist - The tab button container
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabBar {
        /**
          * Whether to show a border below the tab bar.
          * @default true
         */
        "bordered": boolean;
        /**
          * Whether tabs should stretch to fill available width.
          * @default true
         */
        "fullWidth": boolean;
        /**
          * Position of the tab bar.
          * @allowedValues top | bottom
          * @default 'top'
         */
        "position": 'top' | 'bottom';
        /**
          * The value of the currently selected tab.
         */
        "selected"?: LeOptionValue;
        /**
          * Whether to show labels in icon-only mode.
          * @default false
         */
        "showLabels": boolean;
        /**
          * Size of the tabs.
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Array of tab options defining the tabs to display.
          * @default []
         */
        "tabs": LeOption[];
    }
    /**
     * A tab panel component used as a child of le-tabs.
     * Each le-tab-panel defines both the tab button label and the panel content.
     * The parent le-tabs component automatically reads these panels and creates
     * the tab interface.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabPanel {
        /**
          * Whether this tab is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Get tab configuration for parent component
         */
        "getTabConfig": () => Promise<{ label: string; value: string; iconStart?: string; iconEnd?: string; disabled: boolean; }>;
        /**
          * Get the effective value (value or label as fallback)
         */
        "getValue": () => Promise<string>;
        /**
          * Icon displayed at the end of the tab button.
         */
        "iconEnd"?: string;
        /**
          * Icon displayed at the start of the tab button. Can be an emoji, URL, or icon class.
         */
        "iconStart"?: string;
        /**
          * The label displayed in the tab button.
         */
        "label": string;
        /**
          * Whether to render the panel content only when active (lazy loading). When true, content is not rendered until the tab is first selected. When false (default), content is always in DOM but hidden when inactive.
          * @default false
         */
        "lazy": boolean;
        /**
          * Set the active state (called by parent le-tabs)
         */
        "setActive": (isActive: boolean) => Promise<void>;
        /**
          * The value used to identify this tab. Defaults to the label if not provided.
         */
        "value"?: string;
    }
    /**
     * A flexible tabs component for organizing content into tabbed panels.
     * Supports two modes:
     * 1. **Declarative**: Use `<le-tab-panel>` children to define tabs and content
     * 2. **Programmatic**: Use the `tabs` prop with named slots for content
     * Full keyboard navigation and ARIA support included.
     * @cssprop --le-tabs-border-color - Border color for tab list
     * @cssprop --le-tabs-gap - Gap between tabs
     * @cssprop --le-tabs-indicator-color - Active tab indicator color
     * @cssprop --le-tabs-padding-x - Horizontal padding for tab buttons
     * @cssprop --le-tabs-padding-y - Vertical padding for tab buttons
     * @csspart tablist - The tab button container (role="tablist")
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @csspart panels - Container for panel content
     * @csspart panel - Individual panel containers
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabs {
        /**
          * Whether tabs should stretch to fill available width.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Orientation of the tabs.
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "orientation": 'horizontal' | 'vertical';
        /**
          * Scroll behavior for overflowing tabs.
          * @allowedValues auto | hidden | visible | scroll
          * @default 'auto'
         */
        "overflow": 'auto' | 'hidden' | 'visible' | 'scroll';
        /**
          * Position of the tabs relative to the panels.
          * @allowedValues start | end
          * @default 'start'
         */
        "position": 'start' | 'end';
        /**
          * The value of the currently selected tab. If not provided, defaults to the first tab.
         */
        "selected"?: LeOptionValue;
        /**
          * Size of the tabs.
          * @allowedValues sm | md | lg
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Array of tab options (programmatic mode). If le-tab-panel children exist, they take precedence.
          * @default []
         */
        "tabs": LeOption[];
        /**
          * Tab variant style.
          * @allowedValues underlined | solid | pills | enclosed | icon-only
          * @default 'underlined'
         */
        "variant": 'underlined' | 'solid' | 'pills' | 'enclosed' | 'icon-only';
        /**
          * Wrap the tabs if they exceed container width.
          * @default false
         */
        "wrap": boolean;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface LeTag {
        /**
          * Whether the tag is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the tag can be dismissed (shows close button).
          * @default false
         */
        "dismissible": boolean;
        /**
          * Icon to display before the label. Can be an emoji, URL, or icon name.
         */
        "icon"?: string;
        /**
          * The text label to display in the tag.
         */
        "label": string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * The size of the tag.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The visual variant of the tag.
          * @default 'default'
         */
        "variant": 'default' | 'primary' | 'success' | 'warning' | 'danger';
    }
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface LeText {
        /**
          * Text alignment
          * @allowedValues left | center | right | justify
          * @default 'left'
         */
        "align": 'left' | 'center' | 'right' | 'justify';
        /**
          * Text color (CSS value or theme token)
         */
        "color"?: string;
        /**
          * Maximum number of lines before truncating (requires truncate=true)
         */
        "maxLines"?: number;
        /**
          * Whether the text should truncate with ellipsis
          * @default false
         */
        "truncate": boolean;
        /**
          * The semantic variant/type of text element
          * @allowedValues p | h1 | h2 | h3 | h4 | h5 | h6 | code | quote | label | small
          * @default 'p'
         */
        "variant": | 'p'
    | 'h1'
    | 'h2'
    | 'h3'
    | 'h4'
    | 'h5'
    | 'h6'
    | 'code'
    | 'quote'
    | 'label'
    | 'small';
    }
    interface LeTurntable {
        /**
          * @default 'center'
         */
        "center": string;
        /**
          * @default 0
         */
        "value": number;
    }
}
export interface LeBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeBarElement;
}
export interface LeButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeButtonElement;
}
export interface LeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeCheckboxElement;
}
export interface LeCodeInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeCodeInputElement;
}
export interface LeComboboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeComboboxElement;
}
export interface LeDropdownBaseCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeDropdownBaseElement;
}
export interface LeHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeHeaderElement;
}
export interface LeMultiselectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeMultiselectElement;
}
export interface LeNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeNavigationElement;
}
export interface LeNumberInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeNumberInputElement;
}
export interface LePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLePopoverElement;
}
export interface LePopupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLePopupElement;
}
export interface LeSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSegmentedControlElement;
}
export interface LeSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSelectElement;
}
export interface LeSidePanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSidePanelElement;
}
export interface LeSidePanelToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSidePanelToggleElement;
}
export interface LeSlotCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSlotElement;
}
export interface LeStringInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeStringInputElement;
}
export interface LeTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeTabElement;
}
export interface LeTabBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeTabBarElement;
}
export interface LeTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeTabsElement;
}
export interface LeTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeTagElement;
}
declare global {
    interface HTMLLeBarElementEventMap {
        "leBarOverflowChange": LeBarOverflowChangeDetail;
    }
    /**
     * A flexible bar component that handles overflow gracefully.
     * Items are slotted children. The bar measures which items fit on the first
     * row and handles overflow according to the `overflow` prop.
     * @csspart container - The main bar container
     * @csspart item - Individual items in the bar
     * @csspart more-button - The "more" overflow button
     * @csspart hamburger-button - The hamburger menu button
     * @csspart arrow-start - The start (left) scroll arrow
     * @csspart arrow-end - The end (right) scroll arrow
     * @csspart all-menu-button - The "show all" menu button
     * @csspart popover-content - The popover content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeBarElement extends Components.LeBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeBarElementEventMap>(type: K, listener: (this: HTMLLeBarElement, ev: LeBarCustomEvent<HTMLLeBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeBarElementEventMap>(type: K, listener: (this: HTMLLeBarElement, ev: LeBarCustomEvent<HTMLLeBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeBarElement: {
        prototype: HTMLLeBarElement;
        new (): HTMLLeBarElement;
    };
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeBoxElement extends Components.LeBox, HTMLStencilElement {
    }
    var HTMLLeBoxElement: {
        prototype: HTMLLeBoxElement;
        new (): HTMLLeBoxElement;
    };
    interface HTMLLeButtonElementEventMap {
        "click": MouseEvent;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface HTMLLeButtonElement extends Components.LeButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeButtonElementEventMap>(type: K, listener: (this: HTMLLeButtonElement, ev: LeButtonCustomEvent<HTMLLeButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeButtonElementEventMap>(type: K, listener: (this: HTMLLeButtonElement, ev: LeButtonCustomEvent<HTMLLeButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeButtonElement: {
        prototype: HTMLLeButtonElement;
        new (): HTMLLeButtonElement;
    };
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeCardElement extends Components.LeCard, HTMLStencilElement {
    }
    var HTMLLeCardElement: {
        prototype: HTMLLeCardElement;
        new (): HTMLLeCardElement;
    };
    interface HTMLLeCheckboxElementEventMap {
        "change": { checked: boolean; value: string; name: string; externalId: string };
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface HTMLLeCheckboxElement extends Components.LeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeCheckboxElementEventMap>(type: K, listener: (this: HTMLLeCheckboxElement, ev: LeCheckboxCustomEvent<HTMLLeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeCheckboxElementEventMap>(type: K, listener: (this: HTMLLeCheckboxElement, ev: LeCheckboxCustomEvent<HTMLLeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeCheckboxElement: {
        prototype: HTMLLeCheckboxElement;
        new (): HTMLLeCheckboxElement;
    };
    interface HTMLLeCodeInputElementEventMap {
        "leChange": { value: string; name: string; externalId: string };
        "leInput": { value: string; name: string; externalId: string };
        "leFocus": void;
        "leBlur": void;
    }
    /**
     * A one-time code input component with individual frames for each character.
     * Supports standard copy/paste and range selection behaviors.
     * @cssprop --le-code-box-size - Size of each character box (default: 40px width, 48px height)
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     */
    interface HTMLLeCodeInputElement extends Components.LeCodeInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeCodeInputElementEventMap>(type: K, listener: (this: HTMLLeCodeInputElement, ev: LeCodeInputCustomEvent<HTMLLeCodeInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeCodeInputElementEventMap>(type: K, listener: (this: HTMLLeCodeInputElement, ev: LeCodeInputCustomEvent<HTMLLeCodeInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeCodeInputElement: {
        prototype: HTMLLeCodeInputElement;
        new (): HTMLLeCodeInputElement;
    };
    /**
     * Animated show/hide wrapper.
     * Supports height collapse (auto->0) and/or fading.
     * Can optionally listen to the nearest `le-header` shrink events.
     * @cssprop --le-collapse-duration - Transition duration
     * @csspart region - Collapsible region
     * @csspart content - Inner content
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeCollapseElement extends Components.LeCollapse, HTMLStencilElement {
    }
    var HTMLLeCollapseElement: {
        prototype: HTMLLeCollapseElement;
        new (): HTMLLeCollapseElement;
    };
    interface HTMLLeComboboxElementEventMap {
        "leChange": LeOptionSelectDetail;
        "leInput": { value: string };
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface HTMLLeComboboxElement extends Components.LeCombobox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeComboboxElementEventMap>(type: K, listener: (this: HTMLLeComboboxElement, ev: LeComboboxCustomEvent<HTMLLeComboboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeComboboxElementEventMap>(type: K, listener: (this: HTMLLeComboboxElement, ev: LeComboboxCustomEvent<HTMLLeComboboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeComboboxElement: {
        prototype: HTMLLeComboboxElement;
        new (): HTMLLeComboboxElement;
    };
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeComponentElement extends Components.LeComponent, HTMLStencilElement {
    }
    var HTMLLeComponentElement: {
        prototype: HTMLLeComponentElement;
        new (): HTMLLeComponentElement;
    };
    /**
     * Shows a "smart" header title based on what has scrolled out of view.
     * When `selector` matches multiple elements, the title becomes the last element
     * (top-to-bottom) that has fully scrolled out above the viewport.
     * @csspart title - The rendered title
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeCurrentHeadingElement extends Components.LeCurrentHeading, HTMLStencilElement {
    }
    var HTMLLeCurrentHeadingElement: {
        prototype: HTMLLeCurrentHeadingElement;
        new (): HTMLLeCurrentHeadingElement;
    };
    interface HTMLLeDropdownBaseElementEventMap {
        "leOptionSelect": LeOptionSelectDetail;
        "leDropdownOpen": void;
        "leDropdownClose": void;
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeDropdownBaseElement extends Components.LeDropdownBase, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeDropdownBaseElementEventMap>(type: K, listener: (this: HTMLLeDropdownBaseElement, ev: LeDropdownBaseCustomEvent<HTMLLeDropdownBaseElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeDropdownBaseElementEventMap>(type: K, listener: (this: HTMLLeDropdownBaseElement, ev: LeDropdownBaseCustomEvent<HTMLLeDropdownBaseElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeDropdownBaseElement: {
        prototype: HTMLLeDropdownBaseElement;
        new (): HTMLLeDropdownBaseElement;
    };
    interface HTMLLeHeaderElementEventMap {
        "leHeaderState": {
    y: number;
    direction: 'up' | 'down';
    revealed: boolean;
    shrunk: boolean;
  };
        "leHeaderShrinkChange": { shrunk: boolean; y: number };
        "leHeaderVisibilityChange": { visible: boolean; y: number };
    }
    /**
     * A functional page header with scroll-aware behaviors.
     * Features:
     * - Static (default), sticky, or fixed positioning
     * - Optional shrink-on-scroll behavior via `shrink-offset`
     * - Optional reveal-on-scroll-up via `reveal-on-scroll` (sticky only)
     * Slots:
     * - `start`: left side (logo/back button)
     * - `title`: centered/primary title content
     * - `end`: right side actions
     * - default: extra content row (e.g., tabs/search) rendered below main row
     * @cssprop --le-header-bg - Background (color/gradient)
     * @cssprop --le-header-color - Text color
     * @cssprop --le-header-border - Border (e.g. 1px solid ...)
     * @cssprop --le-header-shadow - Shadow/elevation
     * @cssprop --le-header-max-width - Inner content max width
     * @cssprop --le-header-padding-x - Horizontal padding
     * @cssprop --le-header-padding-y - Vertical padding
     * @cssprop --le-header-gap - Gap between zones
     * @cssprop --le-header-height - Base height (main row)
     * @cssprop --le-header-height-condensed - Condensed height when shrunk
     * @cssprop --le-header-transition - Transition timing
     * @cssprop --le-header-z - Z-index (fixed mode)
     * @csspart header - The header container
     * @csspart inner - Inner max-width container
     * @csspart row - Main row
     * @csspart start - Start zone
     * @csspart title - Title zone
     * @csspart end - End zone
     * @csspart secondary - Secondary row
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeHeaderElement extends Components.LeHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeHeaderElementEventMap>(type: K, listener: (this: HTMLLeHeaderElement, ev: LeHeaderCustomEvent<HTMLLeHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeHeaderElementEventMap>(type: K, listener: (this: HTMLLeHeaderElement, ev: LeHeaderCustomEvent<HTMLLeHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeHeaderElement: {
        prototype: HTMLLeHeaderElement;
        new (): HTMLLeHeaderElement;
    };
    /**
     * Placeholder for `le-header`.
     * Reserves space using the global CSS variable `--le-header-height`.
     * The header component updates that variable when it renders.
     * @cssprop --le-header-height - Published header height (px)
     * @cmsInternal true
     */
    interface HTMLLeHeaderPlaceholderElement extends Components.LeHeaderPlaceholder, HTMLStencilElement {
    }
    var HTMLLeHeaderPlaceholderElement: {
        prototype: HTMLLeHeaderPlaceholderElement;
        new (): HTMLLeHeaderPlaceholderElement;
    };
    interface HTMLLeIconElement extends Components.LeIcon, HTMLStencilElement {
    }
    var HTMLLeIconElement: {
        prototype: HTMLLeIconElement;
        new (): HTMLLeIconElement;
    };
    interface HTMLLeMultiselectElementEventMap {
        "leChange": LeMultiOptionSelectDetail;
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface HTMLLeMultiselectElement extends Components.LeMultiselect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeMultiselectElementEventMap>(type: K, listener: (this: HTMLLeMultiselectElement, ev: LeMultiselectCustomEvent<HTMLLeMultiselectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeMultiselectElementEventMap>(type: K, listener: (this: HTMLLeMultiselectElement, ev: LeMultiselectCustomEvent<HTMLLeMultiselectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeMultiselectElement: {
        prototype: HTMLLeMultiselectElement;
        new (): HTMLLeMultiselectElement;
    };
    interface HTMLLeNavigationElementEventMap {
        "leNavItemSelect": LeNavigationItemSelectDetail;
        "leNavItemToggle": LeNavigationItemToggleDetail;
    }
    /**
     * Navigation component with vertical (tree) and horizontal (menu) layouts.
     * - Accepts items as `LeOption[]` or a JSON string.
     * - Supports hierarchical items via `children`.
     * - Supports persisted expansion via `open` on items.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface HTMLLeNavigationElement extends Components.LeNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeNavigationElementEventMap>(type: K, listener: (this: HTMLLeNavigationElement, ev: LeNavigationCustomEvent<HTMLLeNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeNavigationElementEventMap>(type: K, listener: (this: HTMLLeNavigationElement, ev: LeNavigationCustomEvent<HTMLLeNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeNavigationElement: {
        prototype: HTMLLeNavigationElement;
        new (): HTMLLeNavigationElement;
    };
    interface HTMLLeNumberInputElementEventMap {
        "leChange": { value: number; name: string; externalId: string; isValid: boolean };
        "leInput": { value: number; name: string; externalId: string; isValid: boolean };
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface HTMLLeNumberInputElement extends Components.LeNumberInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeNumberInputElementEventMap>(type: K, listener: (this: HTMLLeNumberInputElement, ev: LeNumberInputCustomEvent<HTMLLeNumberInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeNumberInputElementEventMap>(type: K, listener: (this: HTMLLeNumberInputElement, ev: LeNumberInputCustomEvent<HTMLLeNumberInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeNumberInputElement: {
        prototype: HTMLLeNumberInputElement;
        new (): HTMLLeNumberInputElement;
    };
    interface HTMLLePopoverElementEventMap {
        "lePopoverOpen": void;
        "lePopoverClose": void;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLePopoverElement extends Components.LePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLePopoverElementEventMap>(type: K, listener: (this: HTMLLePopoverElement, ev: LePopoverCustomEvent<HTMLLePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLePopoverElementEventMap>(type: K, listener: (this: HTMLLePopoverElement, ev: LePopoverCustomEvent<HTMLLePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLePopoverElement: {
        prototype: HTMLLePopoverElement;
        new (): HTMLLePopoverElement;
    };
    interface HTMLLePopupElementEventMap {
        "leConfirm": PopupResult;
        "leCancel": PopupResult;
        "leOpen": void;
        "leClose": PopupResult;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLePopupElement extends Components.LePopup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLePopupElementEventMap>(type: K, listener: (this: HTMLLePopupElement, ev: LePopupCustomEvent<HTMLLePopupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLePopupElementEventMap>(type: K, listener: (this: HTMLLePopupElement, ev: LePopupCustomEvent<HTMLLePopupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLePopupElement: {
        prototype: HTMLLePopupElement;
        new (): HTMLLePopupElement;
    };
    interface HTMLLeRoundProgressElement extends Components.LeRoundProgress, HTMLStencilElement {
    }
    var HTMLLeRoundProgressElement: {
        prototype: HTMLLeRoundProgressElement;
        new (): HTMLLeRoundProgressElement;
    };
    /**
     * Displays scroll progress as a simple bar.
     * If `track-scroll-progress` is present without a value, tracks the full document.
     * If it is a selector string, tracks progress within the matched element.
     * @cssprop --le-scroll-progress-height - Bar height
     * @cssprop --le-scroll-progress-bg - Track background
     * @cssprop --le-scroll-progress-fill - Fill color
     * @cssprop --le-scroll-progress-sticky-top - If sticky, stop position to parent top
     * @cssprop --le-scroll-progress-fixed-top - If fixed, distance from window top
     * @cssprop --le-scroll-progress-fixed-left - If fixed, distance from window left
     * @cssprop --le-scroll-progress-fixed-right - If fixed, distance from window right
     * @cssprop --le-scroll-progress-z - Z-index of the progress bar (1001 by default, above header)
     * @csspart track - Outer track
     * @csspart fill - Inner fill
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeScrollProgressElement extends Components.LeScrollProgress, HTMLStencilElement {
    }
    var HTMLLeScrollProgressElement: {
        prototype: HTMLLeScrollProgressElement;
        new (): HTMLLeScrollProgressElement;
    };
    interface HTMLLeSegmentedControlElementEventMap {
        "leChange": LeOptionSelectDetail;
    }
    /**
     * A segmented control component (iOS-style toggle buttons).
     * Perfect for toggling between a small set of related options.
     * @cssprop --le-segmented-bg - Background color of the control
     * @cssprop --le-segmented-padding - Padding around segments
     * @cssprop --le-segmented-gap - Gap between segments
     * @cssprop --le-segmented-radius - Border radius of the control
     * @csspart container - The main container
     * @csspart segment - Individual segment buttons
     * @csspart segment-active - The currently active segment
     * @cmsEditable true
     * @cmsCategory Form
     */
    interface HTMLLeSegmentedControlElement extends Components.LeSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSegmentedControlElementEventMap>(type: K, listener: (this: HTMLLeSegmentedControlElement, ev: LeSegmentedControlCustomEvent<HTMLLeSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSegmentedControlElementEventMap>(type: K, listener: (this: HTMLLeSegmentedControlElement, ev: LeSegmentedControlCustomEvent<HTMLLeSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSegmentedControlElement: {
        prototype: HTMLLeSegmentedControlElement;
        new (): HTMLLeSegmentedControlElement;
    };
    interface HTMLLeSelectElementEventMap {
        "change": LeOptionSelectDetail;
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface HTMLLeSelectElement extends Components.LeSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSelectElementEventMap>(type: K, listener: (this: HTMLLeSelectElement, ev: LeSelectCustomEvent<HTMLLeSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSelectElementEventMap>(type: K, listener: (this: HTMLLeSelectElement, ev: LeSelectCustomEvent<HTMLLeSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSelectElement: {
        prototype: HTMLLeSelectElement;
        new (): HTMLLeSelectElement;
    };
    interface HTMLLeSidePanelElementEventMap {
        "leSidePanelOpenChange": { open: boolean; panelId?: string };
        "leSidePanelCollapsedChange": { collapsed: boolean; panelId?: string };
        "leSidePanelWidthChange": { width: number; panelId?: string };
    }
    interface HTMLLeSidePanelElement extends Components.LeSidePanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSidePanelElementEventMap>(type: K, listener: (this: HTMLLeSidePanelElement, ev: LeSidePanelCustomEvent<HTMLLeSidePanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSidePanelElementEventMap>(type: K, listener: (this: HTMLLeSidePanelElement, ev: LeSidePanelCustomEvent<HTMLLeSidePanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSidePanelElement: {
        prototype: HTMLLeSidePanelElement;
        new (): HTMLLeSidePanelElement;
    };
    interface HTMLLeSidePanelToggleElementEventMap {
        "leSidePanelRequestToggle": LeSidePanelRequestToggleDetail;
    }
    interface HTMLLeSidePanelToggleElement extends Components.LeSidePanelToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSidePanelToggleElementEventMap>(type: K, listener: (this: HTMLLeSidePanelToggleElement, ev: LeSidePanelToggleCustomEvent<HTMLLeSidePanelToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSidePanelToggleElementEventMap>(type: K, listener: (this: HTMLLeSidePanelToggleElement, ev: LeSidePanelToggleCustomEvent<HTMLLeSidePanelToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSidePanelToggleElement: {
        prototype: HTMLLeSidePanelToggleElement;
        new (): HTMLLeSidePanelToggleElement;
    };
    interface HTMLLeSlotElementEventMap {
        "leSlotChange": { name: string; value: string; isValid: boolean };
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeSlotElement extends Components.LeSlot, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSlotElementEventMap>(type: K, listener: (this: HTMLLeSlotElement, ev: LeSlotCustomEvent<HTMLLeSlotElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSlotElementEventMap>(type: K, listener: (this: HTMLLeSlotElement, ev: LeSlotCustomEvent<HTMLLeSlotElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSlotElement: {
        prototype: HTMLLeSlotElement;
        new (): HTMLLeSlotElement;
    };
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeStackElement extends Components.LeStack, HTMLStencilElement {
    }
    var HTMLLeStackElement: {
        prototype: HTMLLeStackElement;
        new (): HTMLLeStackElement;
    };
    interface HTMLLeStringInputElementEventMap {
        "change": {
    value: string;
    name: string;
    externalId: string;
  };
        "input": {
    value: string;
    name: string;
    externalId: string;
  };
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface HTMLLeStringInputElement extends Components.LeStringInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeStringInputElementEventMap>(type: K, listener: (this: HTMLLeStringInputElement, ev: LeStringInputCustomEvent<HTMLLeStringInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeStringInputElementEventMap>(type: K, listener: (this: HTMLLeStringInputElement, ev: LeStringInputCustomEvent<HTMLLeStringInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeStringInputElement: {
        prototype: HTMLLeStringInputElement;
        new (): HTMLLeStringInputElement;
    };
    interface HTMLLeTabElementEventMap {
        "click": PointerEvent;
    }
    /**
     * A flexible tab component with multiple variants and states.
     * @cssprop --le-tab-bg - Tab background color
     * @cssprop --le-tab-color - Tab text color
     * @cssprop --le-tab-border-radius - Tab border radius
     * @cssprop --le-tab-padding-x - Tab horizontal padding
     * @cssprop --le-tab-padding-y - Tab vertical padding
     * @csspart button - The native button element
     * @csspart content - The tab content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface HTMLLeTabElement extends Components.LeTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeTabElementEventMap>(type: K, listener: (this: HTMLLeTabElement, ev: LeTabCustomEvent<HTMLLeTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeTabElementEventMap>(type: K, listener: (this: HTMLLeTabElement, ev: LeTabCustomEvent<HTMLLeTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeTabElement: {
        prototype: HTMLLeTabElement;
        new (): HTMLLeTabElement;
    };
    interface HTMLLeTabBarElementEventMap {
        "leTabChange": LeOptionSelectDetail;
    }
    /**
     * A presentational tab bar component without panels.
     * Use this for navigation/routing scenarios where you manage the content
     * externally based on the selection events. For tabs with built-in panels,
     * use `le-tabs` instead.
     * @cssprop --le-tab-bar-border-color - Border color
     * @cssprop --le-tab-bar-gap - Gap between tabs
     * @cssprop --le-tab-bar-indicator-color - Active indicator color
     * @cssprop --le-tab-bar-padding-x - Horizontal padding for tabs
     * @cssprop --le-tab-bar-padding-y - Vertical padding for tabs
     * @csspart tablist - The tab button container
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface HTMLLeTabBarElement extends Components.LeTabBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeTabBarElementEventMap>(type: K, listener: (this: HTMLLeTabBarElement, ev: LeTabBarCustomEvent<HTMLLeTabBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeTabBarElementEventMap>(type: K, listener: (this: HTMLLeTabBarElement, ev: LeTabBarCustomEvent<HTMLLeTabBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeTabBarElement: {
        prototype: HTMLLeTabBarElement;
        new (): HTMLLeTabBarElement;
    };
    /**
     * A tab panel component used as a child of le-tabs.
     * Each le-tab-panel defines both the tab button label and the panel content.
     * The parent le-tabs component automatically reads these panels and creates
     * the tab interface.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface HTMLLeTabPanelElement extends Components.LeTabPanel, HTMLStencilElement {
    }
    var HTMLLeTabPanelElement: {
        prototype: HTMLLeTabPanelElement;
        new (): HTMLLeTabPanelElement;
    };
    interface HTMLLeTabsElementEventMap {
        "leTabChange": LeOptionSelectDetail;
    }
    /**
     * A flexible tabs component for organizing content into tabbed panels.
     * Supports two modes:
     * 1. **Declarative**: Use `<le-tab-panel>` children to define tabs and content
     * 2. **Programmatic**: Use the `tabs` prop with named slots for content
     * Full keyboard navigation and ARIA support included.
     * @cssprop --le-tabs-border-color - Border color for tab list
     * @cssprop --le-tabs-gap - Gap between tabs
     * @cssprop --le-tabs-indicator-color - Active tab indicator color
     * @cssprop --le-tabs-padding-x - Horizontal padding for tab buttons
     * @cssprop --le-tabs-padding-y - Vertical padding for tab buttons
     * @csspart tablist - The tab button container (role="tablist")
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @csspart panels - Container for panel content
     * @csspart panel - Individual panel containers
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface HTMLLeTabsElement extends Components.LeTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeTabsElementEventMap>(type: K, listener: (this: HTMLLeTabsElement, ev: LeTabsCustomEvent<HTMLLeTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeTabsElementEventMap>(type: K, listener: (this: HTMLLeTabsElement, ev: LeTabsCustomEvent<HTMLLeTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeTabsElement: {
        prototype: HTMLLeTabsElement;
        new (): HTMLLeTabsElement;
    };
    interface HTMLLeTagElementEventMap {
        "leDismiss": void;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface HTMLLeTagElement extends Components.LeTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeTagElementEventMap>(type: K, listener: (this: HTMLLeTagElement, ev: LeTagCustomEvent<HTMLLeTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeTagElementEventMap>(type: K, listener: (this: HTMLLeTagElement, ev: LeTagCustomEvent<HTMLLeTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeTagElement: {
        prototype: HTMLLeTagElement;
        new (): HTMLLeTagElement;
    };
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface HTMLLeTextElement extends Components.LeText, HTMLStencilElement {
    }
    var HTMLLeTextElement: {
        prototype: HTMLLeTextElement;
        new (): HTMLLeTextElement;
    };
    interface HTMLLeTurntableElement extends Components.LeTurntable, HTMLStencilElement {
    }
    var HTMLLeTurntableElement: {
        prototype: HTMLLeTurntableElement;
        new (): HTMLLeTurntableElement;
    };
    interface HTMLElementTagNameMap {
        "le-bar": HTMLLeBarElement;
        "le-box": HTMLLeBoxElement;
        "le-button": HTMLLeButtonElement;
        "le-card": HTMLLeCardElement;
        "le-checkbox": HTMLLeCheckboxElement;
        "le-code-input": HTMLLeCodeInputElement;
        "le-collapse": HTMLLeCollapseElement;
        "le-combobox": HTMLLeComboboxElement;
        "le-component": HTMLLeComponentElement;
        "le-current-heading": HTMLLeCurrentHeadingElement;
        "le-dropdown-base": HTMLLeDropdownBaseElement;
        "le-header": HTMLLeHeaderElement;
        "le-header-placeholder": HTMLLeHeaderPlaceholderElement;
        "le-icon": HTMLLeIconElement;
        "le-multiselect": HTMLLeMultiselectElement;
        "le-navigation": HTMLLeNavigationElement;
        "le-number-input": HTMLLeNumberInputElement;
        "le-popover": HTMLLePopoverElement;
        "le-popup": HTMLLePopupElement;
        "le-round-progress": HTMLLeRoundProgressElement;
        "le-scroll-progress": HTMLLeScrollProgressElement;
        "le-segmented-control": HTMLLeSegmentedControlElement;
        "le-select": HTMLLeSelectElement;
        "le-side-panel": HTMLLeSidePanelElement;
        "le-side-panel-toggle": HTMLLeSidePanelToggleElement;
        "le-slot": HTMLLeSlotElement;
        "le-stack": HTMLLeStackElement;
        "le-string-input": HTMLLeStringInputElement;
        "le-tab": HTMLLeTabElement;
        "le-tab-bar": HTMLLeTabBarElement;
        "le-tab-panel": HTMLLeTabPanelElement;
        "le-tabs": HTMLLeTabsElement;
        "le-tag": HTMLLeTagElement;
        "le-text": HTMLLeTextElement;
        "le-turntable": HTMLLeTurntableElement;
    }
}
declare namespace LocalJSX {
    /**
     * A flexible bar component that handles overflow gracefully.
     * Items are slotted children. The bar measures which items fit on the first
     * row and handles overflow according to the `overflow` prop.
     * @csspart container - The main bar container
     * @csspart item - Individual items in the bar
     * @csspart more-button - The "more" overflow button
     * @csspart hamburger-button - The hamburger menu button
     * @csspart arrow-start - The start (left) scroll arrow
     * @csspart arrow-end - The end (right) scroll arrow
     * @csspart all-menu-button - The "show all" menu button
     * @csspart popover-content - The popover content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBar {
        /**
          * Alignment of items within the bar (maps to justify-content).
          * @default 'start'
         */
        "alignItems"?: 'start' | 'end' | 'center' | 'stretch';
        /**
          * Show scroll arrows when overflow is "scroll".
          * @default false
         */
        "arrows"?: boolean;
        /**
          * Disable the internal overflow popover. When true, the bar still detects overflow and hides items, but doesn't render its own popover. Use this when providing custom overflow handling via the leBarOverflowChange event.
          * @default false
         */
        "disablePopover"?: boolean;
        /**
          * Minimum number of visible items required when using "more" overflow mode. If fewer items would be visible, the bar falls back to hamburger mode. Only applies when overflow is "more".
          * @default 0
         */
        "minVisibleItems"?: number;
        /**
          * Emitted when overflow state changes.
         */
        "onLeBarOverflowChange"?: (event: LeBarCustomEvent<LeBarOverflowChangeDetail>) => void;
        /**
          * Overflow behavior when items don't fit on one row. - `more`: Overflow items appear in a "more" dropdown - `scroll`: Items scroll horizontally with optional arrows - `hamburger`: All items go into a hamburger menu if any overflow - `wrap`: Items wrap to additional rows
          * @default 'more'
         */
        "overflow"?: 'more' | 'scroll' | 'hamburger' | 'wrap';
        /**
          * Show an "all items" menu button. - `false`: Don't show - `true` or `'end'`: Show at end - `'start'`: Show at start
          * @default false
         */
        "showAllMenu"?: boolean | 'start' | 'end';
    }
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBox {
        /**
          * Internal horizontal alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'stretch'
         */
        "alignContent"?: 'start' | 'center' | 'end' | 'stretch';
        /**
          * Self-alignment override for this item on the cross axis
          * @allowedValues auto | start | center | end | stretch | baseline
          * @default 'auto'
         */
        "alignSelf"?: 'auto' | 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Background color or CSS value (e.g., '#f0f0f0', 'var(--le-color-primary-light)')
         */
        "background"?: string;
        /**
          * Flex basis - initial size before growing/shrinking (e.g., '200px', '25%', 'auto')
          * @default 'auto'
         */
        "basis"?: string;
        /**
          * Border style (e.g., '1px solid #ccc', '2px dashed var(--le-color-border)')
         */
        "border"?: string;
        /**
          * Border radius (e.g., '8px', 'var(--le-radius-md)')
         */
        "borderRadius"?: string;
        /**
          * Whether to display box content as flex (for internal alignment)
          * @default false
         */
        "displayFlex"?: boolean;
        /**
          * Flex grow factor - how much the item should grow relative to siblings
          * @min 0
          * @default 0
         */
        "grow"?: number;
        /**
          * Height of the box (CSS value)
         */
        "height"?: string;
        /**
          * Direction of internal flex layout when displayFlex is true
          * @allowedValues horizontal | vertical
          * @default 'vertical'
         */
        "innerDirection"?: 'horizontal' | 'vertical';
        /**
          * Gap between internal flex items when displayFlex is true
         */
        "innerGap"?: string;
        /**
          * Internal vertical alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'start'
         */
        "justifyContent"?: 'start' | 'center' | 'end' | 'stretch';
        /**
          * Maximum height constraint
         */
        "maxHeight"?: string;
        /**
          * Maximum width constraint
         */
        "maxWidth"?: string;
        /**
          * Minimum height constraint
         */
        "minHeight"?: string;
        /**
          * Minimum width constraint
         */
        "minWidth"?: string;
        /**
          * Order in the flex container (lower values come first)
         */
        "order"?: number;
        /**
          * Padding inside the box (CSS value like '8px', '1rem')
         */
        "padding"?: string;
        /**
          * Flex shrink factor - how much the item should shrink relative to siblings
          * @min 0
          * @default 1
         */
        "shrink"?: number;
        /**
          * Width of the box (CSS value like '100px', '50%', 'auto')
         */
        "width"?: string;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeButton {
        /**
          * Alignment of the button label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align"?: 'start' | 'center' | 'space-between' | 'end';
        /**
          * Button color theme (uses theme semantic colors)
          * @allowedValues primary | secondary | success | warning | danger | info
          * @default 'primary'
         */
        "color"?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Whether the button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the button takes full width of its container
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Optional href to make the button act as a link
         */
        "href"?: string;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Icon only button image or emoji if this prop is set, the button will render only the icon slot
         */
        "iconOnly"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Emitted when the button is clicked. This is a custom event that wraps the native click but ensures the target is the le-button.
         */
        "onClick"?: (event: LeButtonCustomEvent<MouseEvent>) => void;
        /**
          * Whether the button is in a selected/active state
          * @default false
         */
        "selected"?: boolean;
        /**
          * Button size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * The button type attribute
          * @allowedValues button | submit | reset
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * Button variant style
          * @allowedValues solid | outlined | clear
          * @default 'solid'
         */
        "variant"?: 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCard {
        /**
          * Whether the card is interactive (clickable)
          * @default false
         */
        "interactive"?: boolean;
        /**
          * Card variant style
          * @allowedValues default | outlined | elevated
          * @default 'default'
         */
        "variant"?: 'default' | 'outlined' | 'elevated';
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface LeCheckbox {
        /**
          * Whether the checkbox is checked
          * @default false
         */
        "checked"?: boolean;
        /**
          * Whether the checkbox is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems (e.g. database ID, PDF form field ID)
         */
        "externalId"?: string;
        /**
          * The name of the checkbox input
         */
        "name"?: string;
        /**
          * Emitted when the checked state changes
         */
        "onChange"?: (event: LeCheckboxCustomEvent<{ checked: boolean; value: string; name: string; externalId: string }>) => void;
        /**
          * The value of the checkbox input
         */
        "value"?: string;
    }
    /**
     * A one-time code input component with individual frames for each character.
     * Supports standard copy/paste and range selection behaviors.
     * @cssprop --le-code-box-size - Size of each character box (default: 40px width, 48px height)
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     */
    interface LeCodeInput {
        /**
          * Description text displayed below the input in case there is a more complex markup, it can be provided via slot as well
         */
        "description"?: string;
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Internal validation state (can be set externally manually or via simple check)
          * @default false
         */
        "error"?: boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId"?: string;
        /**
          * Label for the input
         */
        "label"?: string;
        /**
          * Length of the code (number of characters)
          * @default 6
         */
        "length"?: number;
        /**
          * The name of the input
         */
        "name"?: string;
        /**
          * Emitted when the input is blurred
         */
        "onLeBlur"?: (event: LeCodeInputCustomEvent<void>) => void;
        /**
          * Emitted when the value changes (on blur or Enter)
         */
        "onLeChange"?: (event: LeCodeInputCustomEvent<{ value: string; name: string; externalId: string }>) => void;
        /**
          * Emitted when the input is focused
         */
        "onLeFocus"?: (event: LeCodeInputCustomEvent<void>) => void;
        /**
          * Emitted when the input value changes (on keystroke)
         */
        "onLeInput"?: (event: LeCodeInputCustomEvent<{ value: string; name: string; externalId: string }>) => void;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * The type of code (numeric or alphanumeric) This affects the keyboard layout on mobile devices.
          * @default 'text'
         */
        "type"?: 'text' | 'number';
        /**
          * The value of the input
          * @default ''
         */
        "value"?: string;
    }
    /**
     * Animated show/hide wrapper.
     * Supports height collapse (auto->0) and/or fading.
     * Can optionally listen to the nearest `le-header` shrink events.
     * @cssprop --le-collapse-duration - Transition duration
     * @csspart region - Collapsible region
     * @csspart content - Inner content
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCollapse {
        /**
          * Since Stencil boolean props default to `false` when the attribute is missing. instead of `open` defaulting to `true`, using a `closed` prop.
          * @default false
         */
        "closed"?: boolean;
        /**
          * If true, collapse/expand based on the nearest header shrink event.
          * @default false
         */
        "collapseOnHeaderShrink"?: boolean;
        /**
          * Stop fading the content when collapsing/expanding.
          * @default false
         */
        "noFading"?: boolean;
        /**
          * Whether the content should scroll down from the top when open.
          * @default false
         */
        "scrollDown"?: boolean;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface LeCombobox {
        /**
          * Whether to allow custom values not in the options list.
          * @default false
         */
        "allowCustom"?: boolean;
        /**
          * Whether the combobox is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Minimum characters before showing filtered results.
          * @default 0
         */
        "minSearchLength"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected value changes.
         */
        "onLeChange"?: (event: LeComboboxCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeComboboxCustomEvent<void>) => void;
        /**
          * Emitted when the input value changes (for custom values).
         */
        "onLeInput"?: (event: LeComboboxCustomEvent<{ value: string }>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeComboboxCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text for the input.
          * @default 'Type to search...'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Size variant of the combobox.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
    }
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeComponent {
        /**
          * The tag name of the component (e.g., 'le-card'). Used to look up property metadata and display the component name.
         */
        "component": string;
        /**
          * Optional display name for the component. If not provided, the tag name will be formatted as the display name.
         */
        "displayName"?: string;
        /**
          * Classes to apply to the host element. Allows parent components to pass their styling classes.
         */
        "hostClass"?: string;
        /**
          * Inline styles to apply to the host element. Allows parent components to pass dynamic styles (e.g., flex properties).
         */
        "hostStyle"?: { [key: string]: string };
    }
    /**
     * Shows a "smart" header title based on what has scrolled out of view.
     * When `selector` matches multiple elements, the title becomes the last element
     * (top-to-bottom) that has fully scrolled out above the viewport.
     * @csspart title - The rendered title
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCurrentHeading {
        /**
          * CSS selector for page title/headings to watch (e.g. `.page-title`, `main h2`).
          * @default ''
         */
        "selector"?: string;
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeDropdownBase {
        /**
          * Whether to close the dropdown when clicking outside. (used to support combobox with input focus)
          * @default true
         */
        "closeOnClickOutside"?: boolean;
        /**
          * Whether the dropdown is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Placeholder text when no options match filter.
          * @default 'No options'
         */
        "emptyText"?: string;
        /**
          * Filter function for options. Return true to include the option.
         */
        "filterFn"?: (option: LeOption, query: string) => boolean;
        /**
          * Current filter query string.
          * @default ''
         */
        "filterQuery"?: string;
        /**
          * Sets the dropdown to full width of the trigger.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Maximum height of the dropdown list.
          * @default '300px'
         */
        "maxHeight"?: string;
        /**
          * Whether multiple selection is allowed.
          * @default false
         */
        "multiple"?: boolean;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeDropdownClose"?: (event: LeDropdownBaseCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeDropdownOpen"?: (event: LeDropdownBaseCustomEvent<void>) => void;
        /**
          * Emitted when an option is selected.
         */
        "onLeOptionSelect"?: (event: LeDropdownBaseCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Whether the dropdown is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[];
        /**
          * Whether to show checkboxes for multiselect mode.
          * @default true
         */
        "showCheckboxes"?: boolean;
        /**
          * Current value(s) - single value or array for multiselect.
         */
        "value"?: LeOptionValue | LeOptionValue[];
        /**
          * Width of the dropdown. If not set, matches trigger width.
         */
        "width"?: string;
    }
    /**
     * A functional page header with scroll-aware behaviors.
     * Features:
     * - Static (default), sticky, or fixed positioning
     * - Optional shrink-on-scroll behavior via `shrink-offset`
     * - Optional reveal-on-scroll-up via `reveal-on-scroll` (sticky only)
     * Slots:
     * - `start`: left side (logo/back button)
     * - `title`: centered/primary title content
     * - `end`: right side actions
     * - default: extra content row (e.g., tabs/search) rendered below main row
     * @cssprop --le-header-bg - Background (color/gradient)
     * @cssprop --le-header-color - Text color
     * @cssprop --le-header-border - Border (e.g. 1px solid ...)
     * @cssprop --le-header-shadow - Shadow/elevation
     * @cssprop --le-header-max-width - Inner content max width
     * @cssprop --le-header-padding-x - Horizontal padding
     * @cssprop --le-header-padding-y - Vertical padding
     * @cssprop --le-header-gap - Gap between zones
     * @cssprop --le-header-height - Base height (main row)
     * @cssprop --le-header-height-condensed - Condensed height when shrunk
     * @cssprop --le-header-transition - Transition timing
     * @cssprop --le-header-z - Z-index (fixed mode)
     * @csspart header - The header container
     * @csspart inner - Inner max-width container
     * @csspart row - Main row
     * @csspart start - Start zone
     * @csspart title - Title zone
     * @csspart end - End zone
     * @csspart secondary - Secondary row
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeHeader {
        /**
          * If true, expand the header when hovered
          * @default false
         */
        "expandOnHover"?: boolean;
        /**
          * Fixed positioning (out-of-flow). Takes precedence over `sticky`/`static`.
          * @default false
         */
        "fixed"?: boolean;
        /**
          * Force static positioning (default). Ignored if `sticky` or `fixed` are true.
          * @default false
         */
        "isStatic"?: boolean;
        /**
          * Emits when the header shrinks/expands (only on change).
         */
        "onLeHeaderShrinkChange"?: (event: LeHeaderCustomEvent<{ shrunk: boolean; y: number }>) => void;
        /**
          * Emits whenever scroll-driven state changes.
         */
        "onLeHeaderState"?: (event: LeHeaderCustomEvent<{
    y: number;
    direction: 'up' | 'down';
    revealed: boolean;
    shrunk: boolean;
  }>) => void;
        /**
          * Emits when the header hides/shows (only on change).
         */
        "onLeHeaderVisibilityChange"?: (event: LeHeaderCustomEvent<{ visible: boolean; y: number }>) => void;
        /**
          * Sticky-only reveal behavior (hide on scroll down, show on scroll up). - missing/false: disabled - true/empty attribute: enabled with default threshold (16) - number (as string): enabled and used as threshold
         */
        "revealOnScroll"?: string;
        /**
          * Shrink trigger. - missing/0: disabled - number (px): shrink when scrollY >= that value (but never before header height) - css var name (e.g. --foo): shrink when scrollY >= resolved var value - selector (e.g. .page-title): shrink when that element scrolls out of view above the viewport
         */
        "shrinkOffset"?: string;
        /**
          * Sticky positioning (in-flow). Ignored if `fixed` is true.
          * @default false
         */
        "sticky"?: boolean;
    }
    /**
     * Placeholder for `le-header`.
     * Reserves space using the global CSS variable `--le-header-height`.
     * The header component updates that variable when it renders.
     * @cssprop --le-header-height - Published header height (px)
     * @cmsInternal true
     */
    interface LeHeaderPlaceholder {
    }
    interface LeIcon {
        /**
          * Name of the icon to display. Corresponds to a JSON file in the assets folder. For example, "search" will load the "search.json" file.
          * @default null
         */
        "name"?: string;
        /**
          * Size of the icon in pixels. Default is 16.
          * @default 16
         */
        "size"?: number;
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface LeMultiselect {
        /**
          * Whether the multiselect is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Maximum number of selections allowed.
         */
        "maxSelections"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected values change.
         */
        "onLeChange"?: (event: LeMultiselectCustomEvent<LeMultiOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeMultiselectCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeMultiselectCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text when no options are selected.
          * @default 'Select options...'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable"?: boolean;
        /**
          * Whether to show a "Select All" option. Also accepts a string or array of strings to customize the label(s).
          * @default false
         */
        "showSelectAll"?: boolean | string | string[];
        /**
          * Size variant of the multiselect.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected values.
          * @default []
         */
        "value"?: LeOptionValue[];
    }
    /**
     * Navigation component with vertical (tree) and horizontal (menu) layouts.
     * - Accepts items as `LeOption[]` or a JSON string.
     * - Supports hierarchical items via `children`.
     * - Supports persisted expansion via `open` on items.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeNavigation {
        /**
          * Active url for automatic selection.
          * @default ''
         */
        "activeUrl"?: string;
        /**
          * Alignment of the menu items within the navigation bar.
          * @default 'start'
         */
        "align"?: 'start' | 'end' | 'center' | 'space-between';
        /**
          * Text shown when no items match the filter.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Navigation items. Can be passed as an array or JSON string (same pattern as le-select).
          * @default []
         */
        "items"?: LeOption[] | string;
        /**
          * Minimum number of visible top-level items required to use the "More" overflow. If fewer would be visible, the navigation falls back to hamburger.
          * @default 2
         */
        "minVisibleItemsForMore"?: number;
        /**
          * Fired when a navigation item is activated.  This event is cancelable. Call `event.preventDefault()` to prevent default browser navigation and implement custom routing.
         */
        "onLeNavItemSelect"?: (event: LeNavigationCustomEvent<LeNavigationItemSelectDetail>) => void;
        /**
          * Fired when a tree branch is toggled.
         */
        "onLeNavItemToggle"?: (event: LeNavigationCustomEvent<LeNavigationItemToggleDetail>) => void;
        /**
          * Layout orientation.
          * @default 'horizontal'
         */
        "orientation"?: 'vertical' | 'horizontal';
        /**
          * Overflow behavior for horizontal, non-wrapping menus. - more: moves overflow items into a "More" popover - hamburger: turns the whole nav into a hamburger popover
          * @default 'more'
         */
        "overflowMode"?: 'more' | 'hamburger';
        /**
          * Placeholder text for the search input.
          * @default 'Search...'
         */
        "searchPlaceholder"?: string;
        /**
          * Enables a search input for the vertical navigation.
          * @default false
         */
        "searchable"?: boolean;
        /**
          * Whether submenu popovers should include a filter input.
          * @default false
         */
        "submenuSearchable"?: boolean;
        /**
          * Horizontal wrapping behavior. If false, overflow behavior depends on `overflowMode`.
          * @default false
         */
        "wrap"?: boolean;
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeNumberInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId"?: string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Label for the input
         */
        "label"?: string;
        /**
          * Maximum allowed value
         */
        "max"?: number;
        /**
          * Minimum allowed value
         */
        "min"?: number;
        /**
          * The name of the input
         */
        "name"?: string;
        /**
          * Emitted when the value changes (on blur or Enter)
         */
        "onLeChange"?: (event: LeNumberInputCustomEvent<{ value: number; name: string; externalId: string; isValid: boolean }>) => void;
        /**
          * Emitted when the input value changes (on keystroke/spin)
         */
        "onLeInput"?: (event: LeNumberInputCustomEvent<{ value: number; name: string; externalId: string; isValid: boolean }>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Whether the input is required
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether to show the spinner controls
          * @default true
         */
        "showSpinners"?: boolean;
        /**
          * Step value for increment/decrement
          * @default 1
         */
        "step"?: number;
        /**
          * The value of the input
         */
        "value"?: number;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopover {
        /**
          * Alignment of the popover
          * @default 'start'
         */
        "align"?: 'start' | 'center' | 'end';
        /**
          * Whether clicking outside closes the popover
          * @default true
         */
        "closeOnClickOutside"?: boolean;
        /**
          * Whether pressing Escape closes the popover
          * @default true
         */
        "closeOnEscape"?: boolean;
        /**
          * Maximum width for the popover (e.g., '400px', '25rem')
         */
        "maxWidth"?: string;
        /**
          * Minimum width for the popover (e.g., '200px', '15rem')
          * @default '200px'
         */
        "minWidth"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Offset from the trigger element (in pixels)
          * @default 8
         */
        "offset"?: number;
        /**
          * Emitted when the popover closes
         */
        "onLePopoverClose"?: (event: LePopoverCustomEvent<void>) => void;
        /**
          * Emitted when the popover opens
         */
        "onLePopoverOpen"?: (event: LePopoverCustomEvent<void>) => void;
        /**
          * Whether the popover is currently open
          * @default false
         */
        "open"?: boolean;
        /**
          * Optional title for the popover header
         */
        "popoverTitle"?: string;
        /**
          * Position of the popover relative to its trigger
          * @default 'bottom'
         */
        "position"?: 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Whether to show a close button in the header
          * @default true
         */
        "showClose"?: boolean;
        /**
          * Should the popover's trigger take full width of its container
          * @default false
         */
        "triggerFullWidth"?: boolean;
        /**
          * Fixed width for the popover (e.g., '300px', '20rem')
         */
        "width"?: string;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopup {
        /**
          * Text for the cancel button
          * @default 'Cancel'
         */
        "cancelText"?: string;
        /**
          * Whether clicking the backdrop closes the popup (modal only)
          * @default true
         */
        "closeOnBackdrop"?: boolean;
        /**
          * Text for the confirm/OK button
          * @default 'OK'
         */
        "confirmText"?: string;
        /**
          * Default value for prompt input
          * @default ''
         */
        "defaultValue"?: string;
        /**
          * Message text to display (for alert/confirm/prompt types)
         */
        "message"?: string;
        /**
          * Whether the popup is modal (blocks interaction with page behind)
          * @default true
         */
        "modal"?: boolean;
        /**
          * The mode of the Le Kit (e.g., 'default' or 'admin')
          * @default 'default'
         */
        "mode"?: LeKitMode;
        /**
          * Emitted when the popup is cancelled (Cancel clicked or dismissed)
         */
        "onLeCancel"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup closes
         */
        "onLeClose"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup is confirmed (OK clicked)
         */
        "onLeConfirm"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup opens
         */
        "onLeOpen"?: (event: LePopupCustomEvent<void>) => void;
        /**
          * Whether the popup is currently visible
          * @default false
         */
        "open"?: boolean;
        /**
          * Placeholder text for prompt input
          * @default ''
         */
        "placeholder"?: string;
        /**
          * Optional title for the popup header
         */
        "popupTitle"?: string;
        /**
          * Position of the popup on screen
          * @default 'center'
         */
        "position"?: PopupPosition;
        /**
          * Type of popup: alert (OK only), confirm (OK/Cancel), prompt (input + OK/Cancel), custom
          * @default 'alert'
         */
        "type"?: PopupType;
    }
    interface LeRoundProgress {
        /**
          * @default 0
         */
        "padding"?: number;
        "paths"?: string;
        /**
          * @default 0
         */
        "value"?: number;
    }
    /**
     * Displays scroll progress as a simple bar.
     * If `track-scroll-progress` is present without a value, tracks the full document.
     * If it is a selector string, tracks progress within the matched element.
     * @cssprop --le-scroll-progress-height - Bar height
     * @cssprop --le-scroll-progress-bg - Track background
     * @cssprop --le-scroll-progress-fill - Fill color
     * @cssprop --le-scroll-progress-sticky-top - If sticky, stop position to parent top
     * @cssprop --le-scroll-progress-fixed-top - If fixed, distance from window top
     * @cssprop --le-scroll-progress-fixed-left - If fixed, distance from window left
     * @cssprop --le-scroll-progress-fixed-right - If fixed, distance from window right
     * @cssprop --le-scroll-progress-z - Z-index of the progress bar (1001 by default, above header)
     * @csspart track - Outer track
     * @csspart fill - Inner fill
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeScrollProgress {
        /**
          * Boolean or selector string.
         */
        "trackScrollProgress"?: string;
    }
    /**
     * A segmented control component (iOS-style toggle buttons).
     * Perfect for toggling between a small set of related options.
     * @cssprop --le-segmented-bg - Background color of the control
     * @cssprop --le-segmented-padding - Padding around segments
     * @cssprop --le-segmented-gap - Gap between segments
     * @cssprop --le-segmented-radius - Border radius of the control
     * @csspart container - The main container
     * @csspart segment - Individual segment buttons
     * @csspart segment-active - The currently active segment
     * @cmsEditable true
     * @cmsCategory Form
     */
    interface LeSegmentedControl {
        /**
          * Whether the control is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the control should take full width.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Emitted when the selection changes.
         */
        "onLeChange"?: (event: LeSegmentedControlCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Array of options for the segmented control.
          * @default []
         */
        "options"?: LeOption[];
        /**
          * Scroll behavior for overflowing tabs.
          * @allowedValues auto | hidden | visible | scroll
          * @default 'auto'
         */
        "overflow"?: 'auto' | 'hidden' | 'visible' | 'scroll';
        /**
          * Size of the control.
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The value of the currently selected option.
         */
        "value"?: LeOptionValue;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface LeSelect {
        /**
          * Whether the select is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the select should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected value changes.
         */
        "onChange"?: (event: LeSelectCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeSelectCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeSelectCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text when no option is selected.
          * @default 'Select an option'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable"?: boolean;
        /**
          * Size variant of the select.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
        /**
          * Visual variant of the select.
          * @default 'default'
         */
        "variant"?: 'default' | 'outlined' | 'solid';
    }
    interface LeSidePanel {
        /**
          * When crossing to narrow mode, automatically hide the panel (open=false).
          * @default true
         */
        "autoHideOnNarrow"?: boolean;
        /**
          * When crossing to wide mode, automatically show the panel (collapsed=false).
          * @default true
         */
        "autoShowOnWide"?: boolean;
        /**
          * Width breakpoint (in px or a CSS var like `--le-breakpoint-md`) below which the panel enters "narrow" mode.
         */
        "collapseAt"?: string;
        /**
          * Panel collapsed state for wide mode (fully hidden).
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Maximum allowed width when resizable.
          * @default 420
         */
        "maxPanelWidth"?: number;
        /**
          * Minimum allowed width when resizable.
          * @default 220
         */
        "minPanelWidth"?: number;
        /**
          * Behavior when in narrow mode.
          * @default 'overlay'
         */
        "narrowBehavior"?: LeSidePanelNarrowBehavior;
        "onLeSidePanelCollapsedChange"?: (event: LeSidePanelCustomEvent<{ collapsed: boolean; panelId?: string }>) => void;
        "onLeSidePanelOpenChange"?: (event: LeSidePanelCustomEvent<{ open: boolean; panelId?: string }>) => void;
        "onLeSidePanelWidthChange"?: (event: LeSidePanelCustomEvent<{ width: number; panelId?: string }>) => void;
        /**
          * Panel open state for narrow mode. - overlay: controls modal drawer visibility - push: controls whether panel is shown (non-modal)
          * @default false
         */
        "open"?: boolean;
        /**
          * Optional id used to match toggle requests. If set, the panel only responds to toggle events with the same `panelId`.
         */
        "panelId"?: string;
        /**
          * Accessible label for the panel navigation region.
          * @default 'Navigation'
         */
        "panelLabel"?: string;
        /**
          * Default panel width in pixels.
          * @default 280
         */
        "panelWidth"?: number;
        /**
          * When set, panel width + collapsed state are persisted in localStorage.
         */
        "persistKey"?: string;
        /**
          * Allows users to resize the panel by dragging its edge.
          * @default false
         */
        "resizable"?: boolean;
        /**
          * Show a close button inside the panel (primarily used in narrow overlay mode).
          * @default true
         */
        "showCloseButton"?: boolean;
        /**
          * Which side the panel is attached to.
          * @default 'start'
         */
        "side"?: LeSidePanelSide;
    }
    interface LeSidePanelToggle {
        /**
          * Action to emit. Default toggles the panel.
          * @default 'toggle'
         */
        "action"?: LeSidePanelToggleAction;
        /**
          * @default 'center'
         */
        "align"?: 'start' | 'center' | 'space-between' | 'end';
        /**
          * @default 'primary'
         */
        "color"?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Disables the toggle.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "fullWidth"?: boolean;
        "href"?: string;
        "iconEnd"?: string | Node;
        "iconOnly"?: string | Node;
        "iconStart"?: string | Node;
        "mode"?: 'default' | 'admin';
        "onLeSidePanelRequestToggle"?: (event: LeSidePanelToggleCustomEvent<LeSidePanelRequestToggleDetail>) => void;
        /**
          * Optional id used to target a specific panel.
         */
        "panelId"?: string;
        /**
          * @default false
         */
        "selected"?: boolean;
        /**
          * Optional keyboard shortcut like `Mod+B` or `Alt+N`.
         */
        "shortcut"?: string;
        /**
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        "target"?: string;
        /**
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * @default 'solid'
         */
        "variant"?: 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeSlot {
        /**
          * Comma-separated list of allowed component tags for this slot. Used by CMS to filter available components.
          * @example "le-card,le-button,le-text"
         */
        "allowedComponents"?: string;
        /**
          * Description of what content this slot accepts. Shown in admin mode to guide content editors.
         */
        "description"?: string;
        /**
          * Label to display in admin mode. If not provided, the slot name will be used.
         */
        "label"?: string;
        /**
          * Whether multiple components can be dropped in this slot.
          * @default true
         */
        "multiple"?: boolean;
        /**
          * The name of the slot this placeholder represents. Should match the slot name in the parent component.
          * @default ''
         */
        "name"?: string;
        /**
          * Emitted when text content changes in admin mode. The event detail contains the new text value and validity.
         */
        "onLeSlotChange"?: (event: LeSlotCustomEvent<{ name: string; value: string; isValid: boolean }>) => void;
        /**
          * Placeholder text for text/textarea inputs in admin mode.
         */
        "placeholder"?: string;
        /**
          * Whether this slot is required to have content.
          * @default false
         */
        "required"?: boolean;
        /**
          * CSS styles for the slot dropzone container. Useful for layouts - e.g., "flex-direction: row" for horizontal stacks. Only applies in admin mode for type="slot".
         */
        "slotStyle"?: string;
        /**
          * The HTML tag to create when there's no slotted element. Used with type="text" or type="textarea" to auto-create elements.
          * @example "h3" - creates <h3 slot="header">content</h3>
          * @example "p" - creates <p slot="content">content</p>
         */
        "tag"?: string;
        /**
          * The type of slot content. - `slot`: Default, shows a dropzone for components (default) - `text`: Shows a single-line text input - `textarea`: Shows a multi-line text area
          * @default 'slot'
         */
        "type"?: 'slot' | 'text' | 'textarea';
    }
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeStack {
        /**
          * Alignment of items on the cross axis
          * @allowedValues start | center | end | stretch | baseline
          * @default 'stretch'
         */
        "align"?: 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Alignment of wrapped lines (only applies when wrap is true)
          * @allowedValues start | center | end | stretch | space-between | space-around
          * @default 'stretch'
         */
        "alignContent"?: 'start' | 'center' | 'end' | 'stretch' | 'space-between' | 'space-around';
        /**
          * Direction of the stack layout
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "direction"?: 'horizontal' | 'vertical';
        /**
          * Whether the stack should take full height of its container
          * @default false
         */
        "fullHeight"?: boolean;
        /**
          * Whether the stack should take full width of its container
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Gap between items (CSS value like '8px', '1rem', 'var(--le-space-md)')
         */
        "gap"?: string;
        /**
          * Distribution of items on the main axis
          * @allowedValues start | center | end | space-between | space-around | space-evenly
          * @default 'start'
         */
        "justify"?: 'start' | 'center' | 'end' | 'space-between' | 'space-around' | 'space-evenly';
        /**
          * Maximum number of items allowed in the stack (for CMS validation)
          * @min 1
         */
        "maxItems"?: number;
        /**
          * Padding inside the stack container (CSS value)
         */
        "padding"?: string;
        /**
          * Whether to reverse the order of items
          * @default false
         */
        "reverse"?: boolean;
        /**
          * Whether items should wrap to multiple lines
          * @default false
         */
        "wrap"?: boolean;
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeStringInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId"?: string;
        /**
          * Hide description slot
          * @default false
         */
        "hideDescription"?: boolean;
        /**
          * Icon for the end icon
         */
        "iconEnd"?: string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Pass the ref of the input element to the parent component
         */
        "inputRef"?: (el: HTMLInputElement) => void;
        /**
          * Label for the input
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * The name of the input
         */
        "name"?: string;
        /**
          * Emitted when the value changes (on blur or Enter)
         */
        "onChange"?: (event: LeStringInputCustomEvent<{
    value: string;
    name: string;
    externalId: string;
  }>) => void;
        /**
          * Emitted when the input value changes (on keystroke)
         */
        "onInput"?: (event: LeStringInputCustomEvent<{
    value: string;
    name: string;
    externalId: string;
  }>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * The type of the input (text, email, password, etc.)
          * @default 'text'
         */
        "type"?: 'text' | 'email' | 'password' | 'tel' | 'url';
        /**
          * The value of the input
         */
        "value"?: string;
    }
    /**
     * A flexible tab component with multiple variants and states.
     * @cssprop --le-tab-bg - Tab background color
     * @cssprop --le-tab-color - Tab text color
     * @cssprop --le-tab-border-radius - Tab border radius
     * @cssprop --le-tab-padding-x - Tab horizontal padding
     * @cssprop --le-tab-padding-y - Tab vertical padding
     * @csspart button - The native button element
     * @csspart content - The tab content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeTab {
        /**
          * Alignment of the tab label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align"?: 'start' | 'center' | 'space-between' | 'end';
        /**
          * Whether the tab is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the tab can get focus needed for accessibility when used in custom tab implementations
          * @default true
         */
        "focusable"?: boolean;
        /**
          * Whether the tab takes full width of its container
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Optional href to make the tab act as a link
         */
        "href"?: string;
        /**
          * Icon only tab image or emoji if this prop is set, the tab will render only the icon slot
         */
        "icon"?: string | Node;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Label if it is not provided via slot
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Emitted when the tab is clicked. This is a custom event that wraps the native click but ensures the target is the le-tab.
         */
        "onClick"?: (event: LeTabCustomEvent<PointerEvent>) => void;
        /**
          * Position of the tabs when used within a le-tabs component
          * @allowedValues top | bottom | start | end
          * @default 'top'
         */
        "position"?: 'top' | 'bottom' | 'start' | 'end';
        /**
          * Whether the tab is in a selected/active state
          * @default false
         */
        "selected"?: boolean;
        /**
          * Whether to show the label when in icon-only mode
          * @default false
         */
        "showLabel"?: boolean;
        /**
          * Tab size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * Value of the tab, defaults to label if not provided
         */
        "value"?: string;
        /**
          * Tab variant style
          * @allowedValues solid | underlined | clear | enclosed | icon-only
          * @default 'underlined'
         */
        "variant"?: 'underlined' | 'solid' | 'pills' | 'enclosed' | 'icon-only';
    }
    /**
     * A presentational tab bar component without panels.
     * Use this for navigation/routing scenarios where you manage the content
     * externally based on the selection events. For tabs with built-in panels,
     * use `le-tabs` instead.
     * @cssprop --le-tab-bar-border-color - Border color
     * @cssprop --le-tab-bar-gap - Gap between tabs
     * @cssprop --le-tab-bar-indicator-color - Active indicator color
     * @cssprop --le-tab-bar-padding-x - Horizontal padding for tabs
     * @cssprop --le-tab-bar-padding-y - Vertical padding for tabs
     * @csspart tablist - The tab button container
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabBar {
        /**
          * Whether to show a border below the tab bar.
          * @default true
         */
        "bordered"?: boolean;
        /**
          * Whether tabs should stretch to fill available width.
          * @default true
         */
        "fullWidth"?: boolean;
        /**
          * Emitted when the selected tab changes.
         */
        "onLeTabChange"?: (event: LeTabBarCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Position of the tab bar.
          * @allowedValues top | bottom
          * @default 'top'
         */
        "position"?: 'top' | 'bottom';
        /**
          * The value of the currently selected tab.
         */
        "selected"?: LeOptionValue;
        /**
          * Whether to show labels in icon-only mode.
          * @default false
         */
        "showLabels"?: boolean;
        /**
          * Size of the tabs.
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Array of tab options defining the tabs to display.
          * @default []
         */
        "tabs"?: LeOption[];
    }
    /**
     * A tab panel component used as a child of le-tabs.
     * Each le-tab-panel defines both the tab button label and the panel content.
     * The parent le-tabs component automatically reads these panels and creates
     * the tab interface.
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabPanel {
        /**
          * Whether this tab is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Icon displayed at the end of the tab button.
         */
        "iconEnd"?: string;
        /**
          * Icon displayed at the start of the tab button. Can be an emoji, URL, or icon class.
         */
        "iconStart"?: string;
        /**
          * The label displayed in the tab button.
         */
        "label": string;
        /**
          * Whether to render the panel content only when active (lazy loading). When true, content is not rendered until the tab is first selected. When false (default), content is always in DOM but hidden when inactive.
          * @default false
         */
        "lazy"?: boolean;
        /**
          * The value used to identify this tab. Defaults to the label if not provided.
         */
        "value"?: string;
    }
    /**
     * A flexible tabs component for organizing content into tabbed panels.
     * Supports two modes:
     * 1. **Declarative**: Use `<le-tab-panel>` children to define tabs and content
     * 2. **Programmatic**: Use the `tabs` prop with named slots for content
     * Full keyboard navigation and ARIA support included.
     * @cssprop --le-tabs-border-color - Border color for tab list
     * @cssprop --le-tabs-gap - Gap between tabs
     * @cssprop --le-tabs-indicator-color - Active tab indicator color
     * @cssprop --le-tabs-padding-x - Horizontal padding for tab buttons
     * @cssprop --le-tabs-padding-y - Vertical padding for tab buttons
     * @csspart tablist - The tab button container (role="tablist")
     * @csspart tab - Individual tab buttons
     * @csspart tab-active - The currently active tab
     * @csspart panels - Container for panel content
     * @csspart panel - Individual panel containers
     * @cmsEditable true
     * @cmsCategory Navigation
     */
    interface LeTabs {
        /**
          * Whether tabs should stretch to fill available width.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Emitted when the selected tab changes.
         */
        "onLeTabChange"?: (event: LeTabsCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Orientation of the tabs.
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "orientation"?: 'horizontal' | 'vertical';
        /**
          * Scroll behavior for overflowing tabs.
          * @allowedValues auto | hidden | visible | scroll
          * @default 'auto'
         */
        "overflow"?: 'auto' | 'hidden' | 'visible' | 'scroll';
        /**
          * Position of the tabs relative to the panels.
          * @allowedValues start | end
          * @default 'start'
         */
        "position"?: 'start' | 'end';
        /**
          * The value of the currently selected tab. If not provided, defaults to the first tab.
         */
        "selected"?: LeOptionValue;
        /**
          * Size of the tabs.
          * @allowedValues sm | md | lg
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Array of tab options (programmatic mode). If le-tab-panel children exist, they take precedence.
          * @default []
         */
        "tabs"?: LeOption[];
        /**
          * Tab variant style.
          * @allowedValues underlined | solid | pills | enclosed | icon-only
          * @default 'underlined'
         */
        "variant"?: 'underlined' | 'solid' | 'pills' | 'enclosed' | 'icon-only';
        /**
          * Wrap the tabs if they exceed container width.
          * @default false
         */
        "wrap"?: boolean;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface LeTag {
        /**
          * Whether the tag is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the tag can be dismissed (shows close button).
          * @default false
         */
        "dismissible"?: boolean;
        /**
          * Icon to display before the label. Can be an emoji, URL, or icon name.
         */
        "icon"?: string;
        /**
          * The text label to display in the tag.
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Emitted when the dismiss button is clicked.
         */
        "onLeDismiss"?: (event: LeTagCustomEvent<void>) => void;
        /**
          * The size of the tag.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The visual variant of the tag.
          * @default 'default'
         */
        "variant"?: 'default' | 'primary' | 'success' | 'warning' | 'danger';
    }
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface LeText {
        /**
          * Text alignment
          * @allowedValues left | center | right | justify
          * @default 'left'
         */
        "align"?: 'left' | 'center' | 'right' | 'justify';
        /**
          * Text color (CSS value or theme token)
         */
        "color"?: string;
        /**
          * Maximum number of lines before truncating (requires truncate=true)
         */
        "maxLines"?: number;
        /**
          * Whether the text should truncate with ellipsis
          * @default false
         */
        "truncate"?: boolean;
        /**
          * The semantic variant/type of text element
          * @allowedValues p | h1 | h2 | h3 | h4 | h5 | h6 | code | quote | label | small
          * @default 'p'
         */
        "variant"?: | 'p'
    | 'h1'
    | 'h2'
    | 'h3'
    | 'h4'
    | 'h5'
    | 'h6'
    | 'code'
    | 'quote'
    | 'label'
    | 'small';
    }
    interface LeTurntable {
        /**
          * @default 'center'
         */
        "center"?: string;
        /**
          * @default 0
         */
        "value"?: number;
    }
    interface IntrinsicElements {
        "le-bar": LeBar;
        "le-box": LeBox;
        "le-button": LeButton;
        "le-card": LeCard;
        "le-checkbox": LeCheckbox;
        "le-code-input": LeCodeInput;
        "le-collapse": LeCollapse;
        "le-combobox": LeCombobox;
        "le-component": LeComponent;
        "le-current-heading": LeCurrentHeading;
        "le-dropdown-base": LeDropdownBase;
        "le-header": LeHeader;
        "le-header-placeholder": LeHeaderPlaceholder;
        "le-icon": LeIcon;
        "le-multiselect": LeMultiselect;
        "le-navigation": LeNavigation;
        "le-number-input": LeNumberInput;
        "le-popover": LePopover;
        "le-popup": LePopup;
        "le-round-progress": LeRoundProgress;
        "le-scroll-progress": LeScrollProgress;
        "le-segmented-control": LeSegmentedControl;
        "le-select": LeSelect;
        "le-side-panel": LeSidePanel;
        "le-side-panel-toggle": LeSidePanelToggle;
        "le-slot": LeSlot;
        "le-stack": LeStack;
        "le-string-input": LeStringInput;
        "le-tab": LeTab;
        "le-tab-bar": LeTabBar;
        "le-tab-panel": LeTabPanel;
        "le-tabs": LeTabs;
        "le-tag": LeTag;
        "le-text": LeText;
        "le-turntable": LeTurntable;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * A flexible bar component that handles overflow gracefully.
             * Items are slotted children. The bar measures which items fit on the first
             * row and handles overflow according to the `overflow` prop.
             * @csspart container - The main bar container
             * @csspart item - Individual items in the bar
             * @csspart more-button - The "more" overflow button
             * @csspart hamburger-button - The hamburger menu button
             * @csspart arrow-start - The start (left) scroll arrow
             * @csspart arrow-end - The end (right) scroll arrow
             * @csspart all-menu-button - The "show all" menu button
             * @csspart popover-content - The popover content wrapper
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-bar": LocalJSX.LeBar & JSXBase.HTMLAttributes<HTMLLeBarElement>;
            /**
             * A flexible box component for use as a flex item within le-stack.
             * `le-box` wraps content and provides flex item properties like grow, shrink,
             * basis, and self-alignment. It can also control its internal content alignment.
             * @cssprop --le-box-bg - Background color
             * @cssprop --le-box-padding - Padding inside the box
             * @cssprop --le-box-border-radius - Border radius
             * @csspart box - The main box container
             * @csspart content - The inner content wrapper
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-box": LocalJSX.LeBox & JSXBase.HTMLAttributes<HTMLLeBoxElement>;
            /**
             * A flexible button component with multiple variants and states.
             * @cssprop --le-button-bg - Button background color
             * @cssprop --le-button-color - Button text color
             * @cssprop --le-button-border-radius - Button border radius
             * @cssprop --le-button-padding-x - Button horizontal padding
             * @cssprop --le-button-padding-y - Button vertical padding
             * @csspart button - The native button element
             * @csspart content - The button content wrapper
             * @csspart icon-start - The start icon slot
             * @csspart icon-end - The end icon slot
             * @cmsEditable true
             * @cmsCategory Actions
             */
            "le-button": LocalJSX.LeButton & JSXBase.HTMLAttributes<HTMLLeButtonElement>;
            /**
             * A flexible card component with header, content, and footer slots.
             * The card uses le-slot wrappers for each slot area. In admin mode,
             * le-slot shows placeholders for CMS editing. In default mode,
             * le-slot acts as a transparent passthrough.
             * @cssprop --le-card-bg - Card background color
             * @cssprop --le-card-border-radius - Card border radius
             * @cssprop --le-card-shadow - Card box shadow
             * @cssprop --le-card-padding - Card content padding
             * @csspart card - The main card container
             * @csspart header - The card header section
             * @csspart content - The card content section
             * @csspart footer - The card footer section
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-card": LocalJSX.LeCard & JSXBase.HTMLAttributes<HTMLLeCardElement>;
            /**
             * A checkbox component with support for labels, descriptions, and external IDs.
             * @cssprop --le-checkbox-size - Size of the checkbox input
             * @cssprop --le-checkbox-color - Color of the checkbox when checked
             * @cssprop --le-checkbox-label-color - Color of the label text
             * @cssprop --le-checkbox-desc-color - Color of the description text
             */
            "le-checkbox": LocalJSX.LeCheckbox & JSXBase.HTMLAttributes<HTMLLeCheckboxElement>;
            /**
             * A one-time code input component with individual frames for each character.
             * Supports standard copy/paste and range selection behaviors.
             * @cssprop --le-code-box-size - Size of each character box (default: 40px width, 48px height)
             * @cssprop --le-input-bg - Input background color
             * @cssprop --le-input-color - Input text color
             * @cssprop --le-input-border - Input border style
             * @cssprop --le-input-border-focus - Input border style when focused
             * @cssprop --le-input-border-error - Input border style when invalid
             * @cssprop --le-input-radius - Input border radius
             */
            "le-code-input": LocalJSX.LeCodeInput & JSXBase.HTMLAttributes<HTMLLeCodeInputElement>;
            /**
             * Animated show/hide wrapper.
             * Supports height collapse (auto->0) and/or fading.
             * Can optionally listen to the nearest `le-header` shrink events.
             * @cssprop --le-collapse-duration - Transition duration
             * @csspart region - Collapsible region
             * @csspart content - Inner content
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-collapse": LocalJSX.LeCollapse & JSXBase.HTMLAttributes<HTMLLeCollapseElement>;
            /**
             * A combobox component with searchable dropdown.
             * Combines a text input with a dropdown list, allowing users to
             * filter options by typing or select from the list.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic combobox
             * ```html
             * <le-combobox
             * placeholder="Search..."
             * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
             * ></le-combobox>
             * ```
             * @example Allow custom values
             * ```html
             * <le-combobox
             * placeholder="Type or select..."
             * allow-custom
             * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
             * ></le-combobox>
             * ```
             */
            "le-combobox": LocalJSX.LeCombobox & JSXBase.HTMLAttributes<HTMLLeComboboxElement>;
            /**
             * Component wrapper for admin mode editing.
             * This component is used internally by other components to provide admin-mode
             * editing capabilities. It wraps the component's rendered output and shows
             * a settings popover for editing properties.
             * In default mode, it acts as a simple passthrough (display: contents).
             * In admin mode, it shows a border, component name header, and settings popover.
             * The host element is found automatically by traversing up through the shadow DOM.
             * Usage inside a component's render method:
             * ```tsx
             * render() {
             *   return (
             *     <le-component component="le-card">
             *       <Host>...</Host>
             *     </le-component>
             *   );
             * }
             * ```
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-component": LocalJSX.LeComponent & JSXBase.HTMLAttributes<HTMLLeComponentElement>;
            /**
             * Shows a "smart" header title based on what has scrolled out of view.
             * When `selector` matches multiple elements, the title becomes the last element
             * (top-to-bottom) that has fully scrolled out above the viewport.
             * @csspart title - The rendered title
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-current-heading": LocalJSX.LeCurrentHeading & JSXBase.HTMLAttributes<HTMLLeCurrentHeadingElement>;
            /**
             * Internal dropdown base component that provides shared functionality
             * for select, combobox, and multiselect components.
             * Wraps le-popover for positioning and provides:
             * - Option list rendering with groups
             * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
             * - Option filtering support
             * - Single and multi-select modes
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-dropdown-base": LocalJSX.LeDropdownBase & JSXBase.HTMLAttributes<HTMLLeDropdownBaseElement>;
            /**
             * A functional page header with scroll-aware behaviors.
             * Features:
             * - Static (default), sticky, or fixed positioning
             * - Optional shrink-on-scroll behavior via `shrink-offset`
             * - Optional reveal-on-scroll-up via `reveal-on-scroll` (sticky only)
             * Slots:
             * - `start`: left side (logo/back button)
             * - `title`: centered/primary title content
             * - `end`: right side actions
             * - default: extra content row (e.g., tabs/search) rendered below main row
             * @cssprop --le-header-bg - Background (color/gradient)
             * @cssprop --le-header-color - Text color
             * @cssprop --le-header-border - Border (e.g. 1px solid ...)
             * @cssprop --le-header-shadow - Shadow/elevation
             * @cssprop --le-header-max-width - Inner content max width
             * @cssprop --le-header-padding-x - Horizontal padding
             * @cssprop --le-header-padding-y - Vertical padding
             * @cssprop --le-header-gap - Gap between zones
             * @cssprop --le-header-height - Base height (main row)
             * @cssprop --le-header-height-condensed - Condensed height when shrunk
             * @cssprop --le-header-transition - Transition timing
             * @cssprop --le-header-z - Z-index (fixed mode)
             * @csspart header - The header container
             * @csspart inner - Inner max-width container
             * @csspart row - Main row
             * @csspart start - Start zone
             * @csspart title - Title zone
             * @csspart end - End zone
             * @csspart secondary - Secondary row
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-header": LocalJSX.LeHeader & JSXBase.HTMLAttributes<HTMLLeHeaderElement>;
            /**
             * Placeholder for `le-header`.
             * Reserves space using the global CSS variable `--le-header-height`.
             * The header component updates that variable when it renders.
             * @cssprop --le-header-height - Published header height (px)
             * @cmsInternal true
             */
            "le-header-placeholder": LocalJSX.LeHeaderPlaceholder & JSXBase.HTMLAttributes<HTMLLeHeaderPlaceholderElement>;
            "le-icon": LocalJSX.LeIcon & JSXBase.HTMLAttributes<HTMLLeIconElement>;
            /**
             * A multiselect component for selecting multiple options.
             * Displays selected items as tags with optional search filtering.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic multiselect
             * ```html
             * <le-multiselect
             * placeholder="Select options..."
             * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
             * ></le-multiselect>
             * ```
             * @example With max selections
             * ```html
             * <le-multiselect
             * max-selections="3"
             * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
             * ></le-multiselect>
             * ```
             * @example With search
             * ```html
             * <le-multiselect
             * searchable
             * placeholder="Search and select..."
             * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
             * ></le-multiselect>
             * ```
             */
            "le-multiselect": LocalJSX.LeMultiselect & JSXBase.HTMLAttributes<HTMLLeMultiselectElement>;
            /**
             * Navigation component with vertical (tree) and horizontal (menu) layouts.
             * - Accepts items as `LeOption[]` or a JSON string.
             * - Supports hierarchical items via `children`.
             * - Supports persisted expansion via `open` on items.
             * @cmsEditable true
             * @cmsCategory Navigation
             */
            "le-navigation": LocalJSX.LeNavigation & JSXBase.HTMLAttributes<HTMLLeNavigationElement>;
            /**
             * A number input component with validation, keyboard controls, and custom spinners.
             * @cssprop --le-input-bg - Input background color
             * @cssprop --le-input-color - Input text color
             * @cssprop --le-input-border - Input border style
             * @cssprop --le-input-border-focus - Input border style when focused
             * @cssprop --le-input-border-error - Input border style when invalid
             * @cssprop --le-input-radius - Input border radius
             * @cssprop --le-input-padding - Input padding
             */
            "le-number-input": LocalJSX.LeNumberInput & JSXBase.HTMLAttributes<HTMLLeNumberInputElement>;
            /**
             * A popover component for displaying floating content.
             * Uses the native HTML Popover API for proper layering with dialogs
             * and other top-layer elements. Falls back gracefully in older browsers.
             * @csspart trigger - The popover trigger element
             * @csspart content - The popover content wrapper
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-popover": LocalJSX.LePopover & JSXBase.HTMLAttributes<HTMLLePopoverElement>;
            /**
             * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
             * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
             * and focus management. Can be used declaratively in HTML or programmatically
             * via leAlert(), leConfirm(), lePrompt().
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-popup": LocalJSX.LePopup & JSXBase.HTMLAttributes<HTMLLePopupElement>;
            "le-round-progress": LocalJSX.LeRoundProgress & JSXBase.HTMLAttributes<HTMLLeRoundProgressElement>;
            /**
             * Displays scroll progress as a simple bar.
             * If `track-scroll-progress` is present without a value, tracks the full document.
             * If it is a selector string, tracks progress within the matched element.
             * @cssprop --le-scroll-progress-height - Bar height
             * @cssprop --le-scroll-progress-bg - Track background
             * @cssprop --le-scroll-progress-fill - Fill color
             * @cssprop --le-scroll-progress-sticky-top - If sticky, stop position to parent top
             * @cssprop --le-scroll-progress-fixed-top - If fixed, distance from window top
             * @cssprop --le-scroll-progress-fixed-left - If fixed, distance from window left
             * @cssprop --le-scroll-progress-fixed-right - If fixed, distance from window right
             * @cssprop --le-scroll-progress-z - Z-index of the progress bar (1001 by default, above header)
             * @csspart track - Outer track
             * @csspart fill - Inner fill
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-scroll-progress": LocalJSX.LeScrollProgress & JSXBase.HTMLAttributes<HTMLLeScrollProgressElement>;
            /**
             * A segmented control component (iOS-style toggle buttons).
             * Perfect for toggling between a small set of related options.
             * @cssprop --le-segmented-bg - Background color of the control
             * @cssprop --le-segmented-padding - Padding around segments
             * @cssprop --le-segmented-gap - Gap between segments
             * @cssprop --le-segmented-radius - Border radius of the control
             * @csspart container - The main container
             * @csspart segment - Individual segment buttons
             * @csspart segment-active - The currently active segment
             * @cmsEditable true
             * @cmsCategory Form
             */
            "le-segmented-control": LocalJSX.LeSegmentedControl & JSXBase.HTMLAttributes<HTMLLeSegmentedControlElement>;
            /**
             * A select dropdown component for single selection.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic select
             * ```html
             * <le-select
             * placeholder="Choose an option"
             * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
             * ></le-select>
             * ```
             * @example With icons
             * ```html
             * <le-select
             * options='[
             * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
             * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
             * ]'
             * ></le-select>
             * ```
             * @example Grouped options
             * ```html
             * <le-select
             * options='[
             * {"label": "Apple", "value": "apple", "group": "Fruits"},
             * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
             * ]'
             * ></le-select>
             * ```
             */
            "le-select": LocalJSX.LeSelect & JSXBase.HTMLAttributes<HTMLLeSelectElement>;
            "le-side-panel": LocalJSX.LeSidePanel & JSXBase.HTMLAttributes<HTMLLeSidePanelElement>;
            "le-side-panel-toggle": LocalJSX.LeSidePanelToggle & JSXBase.HTMLAttributes<HTMLLeSidePanelToggleElement>;
            /**
             * Slot placeholder component for admin/CMS mode.
             * This component renders a visual placeholder for slots when in admin mode,
             * allowing CMS systems to show available drop zones for content or inline editing.
             * In non-admin mode, this component renders nothing and acts as a passthrough.
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-slot": LocalJSX.LeSlot & JSXBase.HTMLAttributes<HTMLLeSlotElement>;
            /**
             * A flexible stack layout component using CSS flexbox.
             * `le-stack` arranges its children in a row (horizontal) or column (vertical)
             * with configurable spacing, alignment, and wrapping behavior. Perfect for
             * creating responsive layouts.
             * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
             * @csspart stack - The main stack container
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-stack": LocalJSX.LeStack & JSXBase.HTMLAttributes<HTMLLeStackElement>;
            /**
             * A text input component with support for labels, descriptions, icons, and external IDs.
             * @cssprop --le-input-bg - Input background color
             * @cssprop --le-input-color - Input text color
             * @cssprop --le-input-border - Input border style
             * @cssprop --le-input-border-focus - Input border style when focused
             * @cssprop --le-input-radius - Input border radius
             * @cssprop --le-input-padding - Input padding
             */
            "le-string-input": LocalJSX.LeStringInput & JSXBase.HTMLAttributes<HTMLLeStringInputElement>;
            /**
             * A flexible tab component with multiple variants and states.
             * @cssprop --le-tab-bg - Tab background color
             * @cssprop --le-tab-color - Tab text color
             * @cssprop --le-tab-border-radius - Tab border radius
             * @cssprop --le-tab-padding-x - Tab horizontal padding
             * @cssprop --le-tab-padding-y - Tab vertical padding
             * @csspart button - The native button element
             * @csspart content - The tab content wrapper
             * @csspart icon-start - The start icon slot
             * @csspart icon-end - The end icon slot
             * @cmsEditable true
             * @cmsCategory Actions
             */
            "le-tab": LocalJSX.LeTab & JSXBase.HTMLAttributes<HTMLLeTabElement>;
            /**
             * A presentational tab bar component without panels.
             * Use this for navigation/routing scenarios where you manage the content
             * externally based on the selection events. For tabs with built-in panels,
             * use `le-tabs` instead.
             * @cssprop --le-tab-bar-border-color - Border color
             * @cssprop --le-tab-bar-gap - Gap between tabs
             * @cssprop --le-tab-bar-indicator-color - Active indicator color
             * @cssprop --le-tab-bar-padding-x - Horizontal padding for tabs
             * @cssprop --le-tab-bar-padding-y - Vertical padding for tabs
             * @csspart tablist - The tab button container
             * @csspart tab - Individual tab buttons
             * @csspart tab-active - The currently active tab
             * @cmsEditable true
             * @cmsCategory Navigation
             */
            "le-tab-bar": LocalJSX.LeTabBar & JSXBase.HTMLAttributes<HTMLLeTabBarElement>;
            /**
             * A tab panel component used as a child of le-tabs.
             * Each le-tab-panel defines both the tab button label and the panel content.
             * The parent le-tabs component automatically reads these panels and creates
             * the tab interface.
             * @cmsEditable true
             * @cmsCategory Navigation
             */
            "le-tab-panel": LocalJSX.LeTabPanel & JSXBase.HTMLAttributes<HTMLLeTabPanelElement>;
            /**
             * A flexible tabs component for organizing content into tabbed panels.
             * Supports two modes:
             * 1. **Declarative**: Use `<le-tab-panel>` children to define tabs and content
             * 2. **Programmatic**: Use the `tabs` prop with named slots for content
             * Full keyboard navigation and ARIA support included.
             * @cssprop --le-tabs-border-color - Border color for tab list
             * @cssprop --le-tabs-gap - Gap between tabs
             * @cssprop --le-tabs-indicator-color - Active tab indicator color
             * @cssprop --le-tabs-padding-x - Horizontal padding for tab buttons
             * @cssprop --le-tabs-padding-y - Vertical padding for tab buttons
             * @csspart tablist - The tab button container (role="tablist")
             * @csspart tab - Individual tab buttons
             * @csspart tab-active - The currently active tab
             * @csspart panels - Container for panel content
             * @csspart panel - Individual panel containers
             * @cmsEditable true
             * @cmsCategory Navigation
             */
            "le-tabs": LocalJSX.LeTabs & JSXBase.HTMLAttributes<HTMLLeTabsElement>;
            /**
             * A tag/chip component for displaying labels with optional dismiss functionality.
             * @cmsEditable false
             * @cmsCategory Form
             * @example Basic tag
             * ```html
             * <le-tag label="JavaScript"></le-tag>
             * ```
             * @example Dismissible tag
             * ```html
             * <le-tag label="Remove me" dismissible></le-tag>
             * ```
             * @example With icon
             * ```html
             * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
             * ```
             * @example Different sizes
             * ```html
             * <le-tag label="Small" size="small"></le-tag>
             * <le-tag label="Medium" size="medium"></le-tag>
             * <le-tag label="Large" size="large"></le-tag>
             * ```
             * @example Different variants
             * ```html
             * <le-tag label="Default" variant="default"></le-tag>
             * <le-tag label="Primary" variant="primary"></le-tag>
             * <le-tag label="Success" variant="success"></le-tag>
             * <le-tag label="Warning" variant="warning"></le-tag>
             * <le-tag label="Danger" variant="danger"></le-tag>
             * ```
             */
            "le-tag": LocalJSX.LeTag & JSXBase.HTMLAttributes<HTMLLeTagElement>;
            /**
             * A text component with rich text editing capabilities in admin mode.
             * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
             * and provides a Notion-like rich text editor in admin mode with formatting
             * toolbar for bold, italic, links, and paragraph type selection.
             * @cssprop --le-text-color - Text color
             * @cssprop --le-text-font-size - Font size
             * @cssprop --le-text-line-height - Line height
             * @cssprop --le-text-font-weight - Font weight
             * @csspart text - The text container element
             * @cmsEditable true
             * @cmsCategory Content
             */
            "le-text": LocalJSX.LeText & JSXBase.HTMLAttributes<HTMLLeTextElement>;
            "le-turntable": LocalJSX.LeTurntable & JSXBase.HTMLAttributes<HTMLLeTurntableElement>;
        }
    }
}
