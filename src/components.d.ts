/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BlockType, BlockTypeConfig, LeBlock, LeBlockChangeDetail } from "./types/blocks";
import { LeMultiOptionSelectDetail, LeOption, LeOptionSelectDetail, LeOptionValue } from "./types/options";
import { FormatType } from "./components/le-rich-text-editor/le-format-toolbar";
import { PopupPosition, PopupResult, PopupType } from "./components/le-popup/le-popup";
export { BlockType, BlockTypeConfig, LeBlock, LeBlockChangeDetail } from "./types/blocks";
export { LeMultiOptionSelectDetail, LeOption, LeOptionSelectDetail, LeOptionValue } from "./types/options";
export { FormatType } from "./components/le-rich-text-editor/le-format-toolbar";
export { PopupPosition, PopupResult, PopupType } from "./components/le-popup/le-popup";
export namespace Components {
    /**
     * Block menu (command palette) for the rich text editor.
     * Triggered by "/" at the start of a block or clicking the block type icon.
     * @cmsInternal true
     */
    interface LeBlockMenu {
        /**
          * Available block types.
          * @default DEFAULT_BLOCK_CONFIGS
         */
        "blockTypes": BlockTypeConfig[];
        /**
          * Hide the menu.
         */
        "hide": () => Promise<void>;
        /**
          * Whether the menu is visible.
          * @default false
         */
        "open": boolean;
        /**
          * Position to show the menu at.
          * @default { x: 0, y: 0 }
         */
        "position": { x: number; y: number };
        /**
          * Show the menu.
         */
        "show": () => Promise<void>;
    }
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBox {
        /**
          * Internal horizontal alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'stretch'
         */
        "alignContent": 'start' | 'center' | 'end' | 'stretch';
        /**
          * Self-alignment override for this item on the cross axis
          * @allowedValues auto | start | center | end | stretch | baseline
          * @default 'auto'
         */
        "alignSelf": 'auto' | 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Background color or CSS value (e.g., '#f0f0f0', 'var(--le-color-primary-light)')
         */
        "background"?: string;
        /**
          * Flex basis - initial size before growing/shrinking (e.g., '200px', '25%', 'auto')
          * @default 'auto'
         */
        "basis": string;
        /**
          * Border style (e.g., '1px solid #ccc', '2px dashed var(--le-color-border)')
         */
        "border"?: string;
        /**
          * Border radius (e.g., '8px', 'var(--le-radius-md)')
         */
        "borderRadius"?: string;
        /**
          * Whether to display box content as flex (for internal alignment)
          * @default false
         */
        "displayFlex": boolean;
        /**
          * Flex grow factor - how much the item should grow relative to siblings
          * @min 0
          * @default 0
         */
        "grow": number;
        /**
          * Height of the box (CSS value)
         */
        "height"?: string;
        /**
          * Direction of internal flex layout when displayFlex is true
          * @allowedValues horizontal | vertical
          * @default 'vertical'
         */
        "innerDirection": 'horizontal' | 'vertical';
        /**
          * Gap between internal flex items when displayFlex is true
         */
        "innerGap"?: string;
        /**
          * Internal vertical alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'start'
         */
        "justifyContent": 'start' | 'center' | 'end' | 'stretch';
        /**
          * Maximum height constraint
         */
        "maxHeight"?: string;
        /**
          * Maximum width constraint
         */
        "maxWidth"?: string;
        /**
          * Minimum height constraint
         */
        "minHeight"?: string;
        /**
          * Minimum width constraint
         */
        "minWidth"?: string;
        /**
          * Order in the flex container (lower values come first)
         */
        "order"?: number;
        /**
          * Padding inside the box (CSS value like '8px', '1rem')
         */
        "padding"?: string;
        /**
          * Flex shrink factor - how much the item should shrink relative to siblings
          * @min 0
          * @default 1
         */
        "shrink": number;
        /**
          * Width of the box (CSS value like '100px', '50%', 'auto')
         */
        "width"?: string;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeButton {
        /**
          * Alignment of the button label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align": 'start' | 'center' | 'space-between' | 'end';
        /**
          * Button color theme (uses theme semantic colors)
          * @allowedValues primary | secondary | success | warning | danger | info
          * @default 'primary'
         */
        "color": 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Whether the button is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the button takes full width of its container
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Optional href to make the button act as a link
         */
        "href"?: string;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Icon only button image or emoji if this prop is set, the button will render only the icon slot
         */
        "iconOnly"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * Whether the button is in a selected/active state
          * @default false
         */
        "selected": boolean;
        /**
          * Button size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * The button type attribute
          * @allowedValues button | submit | reset
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * Button variant style
          * @allowedValues solid | outlined | clear
          * @default 'solid'
         */
        "variant": 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCard {
        /**
          * Whether the card is interactive (clickable)
          * @default false
         */
        "interactive": boolean;
        /**
          * Card variant style
          * @allowedValues default | outlined | elevated
          * @default 'default'
         */
        "variant": 'default' | 'outlined' | 'elevated';
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface LeCheckbox {
        /**
          * Whether the checkbox is checked
          * @default false
         */
        "checked": boolean;
        /**
          * Whether the checkbox is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems (e.g. database ID, PDF form field ID)
         */
        "externalId": string;
        /**
          * The name of the checkbox input
         */
        "name": string;
        /**
          * The value of the checkbox input
         */
        "value": string;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface LeCombobox {
        /**
          * Whether to allow custom values not in the options list.
          * @default false
         */
        "allowCustom": boolean;
        /**
          * Whether the combobox is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Focuses the input element.
         */
        "focusInput": () => Promise<void>;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Minimum characters before showing filtered results.
          * @default 0
         */
        "minSearchLength": number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text for the input.
          * @default 'Type to search...'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Size variant of the combobox.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
    }
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeComponent {
        /**
          * The tag name of the component (e.g., 'le-card'). Used to look up property metadata and display the component name.
         */
        "component": string;
        /**
          * Optional display name for the component. If not provided, the tag name will be formatted as the display name.
         */
        "displayName"?: string;
        /**
          * Classes to apply to the host element. Allows parent components to pass their styling classes.
         */
        "hostClass"?: string;
        /**
          * Inline styles to apply to the host element. Allows parent components to pass dynamic styles (e.g., flex properties).
         */
        "hostStyle"?: { [key: string]: string };
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeDropdownBase {
        /**
          * Whether to close the dropdown when clicking outside. (used to support combobox with input focus)
          * @default true
         */
        "closeOnClickOutside": boolean;
        /**
          * Whether the dropdown is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Placeholder text when no options match filter.
          * @default 'No options'
         */
        "emptyText": string;
        /**
          * Filter function for options. Return true to include the option.
         */
        "filterFn"?: (option: LeOption, query: string) => boolean;
        /**
          * Current filter query string.
          * @default ''
         */
        "filterQuery": string;
        /**
          * Sets the dropdown to full width of the trigger.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hide": () => Promise<void>;
        /**
          * Maximum height of the dropdown list.
          * @default '300px'
         */
        "maxHeight": string;
        /**
          * Whether multiple selection is allowed.
          * @default false
         */
        "multiple": boolean;
        /**
          * Whether the dropdown is open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[];
        /**
          * Opens the dropdown.
         */
        "show": () => Promise<void>;
        /**
          * Whether to show checkboxes for multiselect mode.
          * @default true
         */
        "showCheckboxes": boolean;
        /**
          * Toggles the dropdown.
         */
        "toggle": () => Promise<void>;
        /**
          * Current value(s) - single value or array for multiselect.
         */
        "value"?: LeOptionValue | LeOptionValue[];
        /**
          * Width of the dropdown. If not set, matches trigger width.
         */
        "width"?: string;
    }
    /**
     * Internal component representing a single block in the rich text editor.
     * @cmsInternal true
     */
    interface LeEditorBlock {
        /**
          * The block data.
         */
        "block": LeBlock;
        /**
          * Focus the editable content area.
         */
        "focusContent": (atEnd?: boolean) => Promise<void>;
        /**
          * Whether this block is currently focused.
          * @default false
         */
        "focused": boolean;
        /**
          * Get the current HTML content.
         */
        "getContent": () => Promise<string>;
        /**
          * For numbered lists, which number to start at (1-based).
          * @default 1
         */
        "listStart": number;
        /**
          * Whether the editor is in readonly mode.
          * @default false
         */
        "readonly": boolean;
        /**
          * Set the HTML content.
         */
        "setContent": (html: string) => Promise<void>;
    }
    /**
     * Floating format toolbar for text selection in the rich text editor.
     * Positions itself above the selection.
     * @cmsInternal true
     */
    interface LeFormatToolbar {
        /**
          * Currently active formats.
          * @default []
         */
        "activeFormats": FormatType[];
        /**
          * Which format buttons to show.
          * @default ['bold', 'italic', 'underline', 'strikethrough', 'code', 'link']
         */
        "formats": FormatType[];
        /**
          * Hide the toolbar.
         */
        "hide": () => Promise<void>;
        /**
          * Whether the toolbar is visible.
          * @default false
         */
        "open": boolean;
        /**
          * Position to show the toolbar at (center-x, top-y of selection).
          * @default { x: 0, y: 0 }
         */
        "position": { x: number; y: number };
        /**
          * Show the toolbar.
         */
        "show": () => Promise<void>;
        /**
          * Update position.
         */
        "updatePosition": (x: number, y: number) => Promise<void>;
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface LeMultiselect {
        /**
          * Clears all selections.
         */
        "clearSelection": () => Promise<void>;
        /**
          * Whether the multiselect is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Maximum number of selections allowed.
         */
        "maxSelections"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text when no options are selected.
          * @default 'Select options...'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Whether to show a "Select All" option. Also accepts a string or array of strings to customize the label(s).
          * @default false
         */
        "showSelectAll": boolean | string | string[];
        /**
          * Size variant of the multiselect.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected values.
          * @default []
         */
        "value": LeOptionValue[];
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeNumberInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId": string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Label for the input
         */
        "label": string;
        /**
          * Maximum allowed value
         */
        "max"?: number;
        /**
          * Minimum allowed value
         */
        "min"?: number;
        /**
          * The name of the input
         */
        "name": string;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * Whether the input is required
          * @default false
         */
        "required": boolean;
        /**
          * Whether to show the spinner controls
          * @default true
         */
        "showSpinners": boolean;
        /**
          * Step value for increment/decrement
          * @default 1
         */
        "step": number;
        /**
          * The value of the input
         */
        "value": number;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopover {
        /**
          * Alignment of the popover
          * @default 'start'
         */
        "align": 'start' | 'center' | 'end';
        /**
          * Whether clicking outside closes the popover
          * @default true
         */
        "closeOnClickOutside": boolean;
        /**
          * Whether pressing Escape closes the popover
          * @default true
         */
        "closeOnEscape": boolean;
        /**
          * Closes the popover
         */
        "hide": () => Promise<void>;
        /**
          * Maximum width for the popover (e.g., '400px', '25rem')
         */
        "maxWidth"?: string;
        /**
          * Minimum width for the popover (e.g., '200px', '15rem')
          * @default '200px'
         */
        "minWidth"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * Offset from the trigger element (in pixels)
          * @default 8
         */
        "offset": number;
        /**
          * Whether the popover is currently open
          * @default false
         */
        "open": boolean;
        /**
          * Optional title for the popover header
         */
        "popoverTitle"?: string;
        /**
          * Position of the popover relative to its trigger
          * @default 'bottom'
         */
        "position": 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Opens the popover
         */
        "show": () => Promise<void>;
        /**
          * Whether to show a close button in the header
          * @default true
         */
        "showClose": boolean;
        /**
          * Toggles the popover
         */
        "toggle": () => Promise<void>;
        /**
          * Should the popover's trigger take full width of its container
          * @default false
         */
        "triggerFullWidth": boolean;
        /**
          * Method to update the popover position from a parent component
         */
        "updatePosition": () => Promise<void>;
        /**
          * Fixed width for the popover (e.g., '300px', '20rem')
         */
        "width"?: string;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically 
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopup {
        /**
          * Text for the cancel button
          * @default 'Cancel'
         */
        "cancelText": string;
        /**
          * Whether clicking the backdrop closes the popup (modal only)
          * @default true
         */
        "closeOnBackdrop": boolean;
        /**
          * Text for the confirm/OK button
          * @default 'OK'
         */
        "confirmText": string;
        /**
          * Default value for prompt input
          * @default ''
         */
        "defaultValue": string;
        /**
          * Closes the popup with a result
         */
        "hide": (confirmed?: boolean) => Promise<void>;
        /**
          * Message text to display (for alert/confirm/prompt types)
         */
        "message"?: string;
        /**
          * Whether the popup is modal (blocks interaction with page behind)
          * @default true
         */
        "modal": boolean;
        /**
          * Whether the popup is currently visible
          * @default false
         */
        "open": boolean;
        /**
          * Placeholder text for prompt input
          * @default ''
         */
        "placeholder": string;
        /**
          * Optional title for the popup header
         */
        "popupTitle"?: string;
        /**
          * Position of the popup on screen
          * @default 'center'
         */
        "position": PopupPosition;
        /**
          * Opens the popup and returns a promise that resolves when closed
         */
        "show": () => Promise<PopupResult>;
        /**
          * Type of popup: alert (OK only), confirm (OK/Cancel), prompt (input + OK/Cancel), custom
          * @default 'alert'
         */
        "type": PopupType;
    }
    /**
     * Rich text editor with block-based editing, similar to Notion.
     * Features:
     * - Block-based content structure (paragraphs, headings, lists, quotes, code, dividers)
     * - Markdown shortcuts (# for headings, - for lists, > for quotes, etc.)
     * - Inline formatting toolbar (bold, italic, underline, strikethrough, code, links)
     * - Block command menu triggered by /
     * - Drag and drop block reordering
     * - HTML and Markdown export
     * @cmsEditable true
     * @cmsCategory Content
     * @example Basic usage
     * ```html
     * <le-rich-text-editor placeholder="Start writing..."></le-rich-text-editor>
     * ```
     * @example With initial content
     * ```html
     * <le-rich-text-editor id="editor"></le-rich-text-editor>
     * <script>
     * const editor = document.getElementById('editor');
     * editor.setHtml('<h1>Hello</h1><p>World</p>');
     * </script>
     * ```
     */
    interface LeRichTextEditor {
        /**
          * Whether to autofocus on mount.
          * @default false
         */
        "autofocus": boolean;
        /**
          * Available block types.
          * @default DEFAULT_BLOCK_CONFIGS
         */
        "blockTypes": BlockTypeConfig[];
        /**
          * Blur the editor.
         */
        "blurEditor": () => Promise<void>;
        /**
          * Focus the editor.
         */
        "focusEditor": () => Promise<void>;
        /**
          * Get the raw block data.
         */
        "getBlocks": () => Promise<LeBlock[]>;
        /**
          * Get the content as HTML.
         */
        "getHtml": () => Promise<string>;
        /**
          * Get the content as Markdown.
         */
        "getMarkdown": () => Promise<string>;
        /**
          * Maximum height (scrollable).
         */
        "maxHeight"?: string;
        /**
          * Minimum height of the editor.
         */
        "minHeight"?: string;
        /**
          * Placeholder text shown in empty editor.
          * @default "Type '/' for commands..."
         */
        "placeholder": string;
        /**
          * Whether the editor is in readonly mode.
          * @default false
         */
        "readonly": boolean;
        /**
          * Set content from HTML.
         */
        "setHtml": (html: string) => Promise<void>;
        /**
          * Initial HTML content.
         */
        "value"?: string;
    }
    interface LeRoundProgress {
        /**
          * @default 0
         */
        "padding": number;
        "paths": string;
        /**
          * @default 0
         */
        "value": number;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface LeSelect {
        /**
          * Whether the select is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText": string;
        /**
          * Whether the select should take full width of its container.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Closes the dropdown.
         */
        "hideDropdown": () => Promise<void>;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open": boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options": LeOption[] | string;
        /**
          * Placeholder text when no option is selected.
          * @default 'Select an option'
         */
        "placeholder": string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required": boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable": boolean;
        /**
          * Opens the dropdown.
         */
        "showDropdown": () => Promise<void>;
        /**
          * Size variant of the select.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
        /**
          * Visual variant of the select.
          * @default 'default'
         */
        "variant": 'default' | 'outlined' | 'solid';
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeSlot {
        /**
          * Comma-separated list of allowed component tags for this slot. Used by CMS to filter available components.
          * @example "le-card,le-button,le-text"
         */
        "allowedComponents"?: string;
        /**
          * Description of what content this slot accepts. Shown in admin mode to guide content editors.
         */
        "description"?: string;
        /**
          * Label to display in admin mode. If not provided, the slot name will be used.
         */
        "label"?: string;
        /**
          * Whether multiple components can be dropped in this slot.
          * @default true
         */
        "multiple": boolean;
        /**
          * The name of the slot this placeholder represents. Should match the slot name in the parent component.
          * @default ''
         */
        "name": string;
        /**
          * Placeholder text for text/textarea inputs in admin mode.
         */
        "placeholder"?: string;
        /**
          * Whether this slot is required to have content.
          * @default false
         */
        "required": boolean;
        /**
          * CSS styles for the slot dropzone container. Useful for layouts - e.g., "flex-direction: row" for horizontal stacks. Only applies in admin mode for type="slot".
         */
        "slotStyle"?: string;
        /**
          * The HTML tag to create when there's no slotted element. Used with type="text" or type="textarea" to auto-create elements.
          * @example "h3" - creates <h3 slot="header">content</h3>
          * @example "p" - creates <p slot="content">content</p>
         */
        "tag"?: string;
        /**
          * The type of slot content. - `slot`: Default, shows a dropzone for components (default) - `text`: Shows a single-line text input - `textarea`: Shows a multi-line text area
          * @default 'slot'
         */
        "type": 'slot' | 'text' | 'textarea';
    }
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeStack {
        /**
          * Alignment of items on the cross axis
          * @allowedValues start | center | end | stretch | baseline
          * @default 'stretch'
         */
        "align": 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Alignment of wrapped lines (only applies when wrap is true)
          * @allowedValues start | center | end | stretch | space-between | space-around
          * @default 'stretch'
         */
        "alignContent": 'start' | 'center' | 'end' | 'stretch' | 'space-between' | 'space-around';
        /**
          * Direction of the stack layout
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "direction": 'horizontal' | 'vertical';
        /**
          * Whether the stack should take full height of its container
          * @default false
         */
        "fullHeight": boolean;
        /**
          * Whether the stack should take full width of its container
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Gap between items (CSS value like '8px', '1rem', 'var(--le-space-md)')
         */
        "gap"?: string;
        /**
          * Distribution of items on the main axis
          * @allowedValues start | center | end | space-between | space-around | space-evenly
          * @default 'start'
         */
        "justify": 'start' | 'center' | 'end' | 'space-between' | 'space-around' | 'space-evenly';
        /**
          * Maximum number of items allowed in the stack (for CMS validation)
          * @min 1
         */
        "maxItems"?: number;
        /**
          * Padding inside the stack container (CSS value)
         */
        "padding"?: string;
        /**
          * Whether to reverse the order of items
          * @default false
         */
        "reverse": boolean;
        /**
          * Whether items should wrap to multiple lines
          * @default false
         */
        "wrap": boolean;
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeStringInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId": string;
        /**
          * Hide description slot
          * @default false
         */
        "hideDescription": boolean;
        /**
          * Icon for the end icon
         */
        "iconEnd": string;
        /**
          * Icon for the start icon
         */
        "iconStart": string;
        /**
          * Pass the ref of the input element to the parent component
         */
        "inputRef"?: (el: HTMLInputElement) => void;
        /**
          * Label for the input
         */
        "label": string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * The name of the input
         */
        "name": string;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly": boolean;
        /**
          * The type of the input (text, email, password, etc.)
          * @default 'text'
         */
        "type": 'text' | 'email' | 'password' | 'tel' | 'url';
        /**
          * The value of the input
         */
        "value": string;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface LeTag {
        /**
          * Whether the tag is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the tag can be dismissed (shows close button).
          * @default false
         */
        "dismissible": boolean;
        /**
          * Icon to display before the label. Can be an emoji, URL, or icon name.
         */
        "icon"?: string;
        /**
          * The text label to display in the tag.
         */
        "label": string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode": 'default' | 'admin';
        /**
          * The size of the tag.
          * @default 'medium'
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The visual variant of the tag.
          * @default 'default'
         */
        "variant": 'default' | 'primary' | 'success' | 'warning' | 'danger';
    }
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface LeText {
        /**
          * Text alignment
          * @allowedValues left | center | right | justify
          * @default 'left'
         */
        "align": 'left' | 'center' | 'right' | 'justify';
        /**
          * Text color (CSS value or theme token)
         */
        "color"?: string;
        /**
          * Maximum number of lines before truncating (requires truncate=true)
         */
        "maxLines"?: number;
        /**
          * Whether the text should truncate with ellipsis
          * @default false
         */
        "truncate": boolean;
        /**
          * The semantic variant/type of text element
          * @allowedValues p | h1 | h2 | h3 | h4 | h5 | h6 | code | quote | label | small
          * @default 'p'
         */
        "variant": 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'code' | 'quote' | 'label' | 'small';
    }
    interface LeTurntable {
        /**
          * @default 'center'
         */
        "center": string;
        /**
          * @default 0
         */
        "value": number;
    }
}
export interface LeBlockMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeBlockMenuElement;
}
export interface LeButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeButtonElement;
}
export interface LeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeCheckboxElement;
}
export interface LeComboboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeComboboxElement;
}
export interface LeDropdownBaseCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeDropdownBaseElement;
}
export interface LeEditorBlockCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeEditorBlockElement;
}
export interface LeFormatToolbarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeFormatToolbarElement;
}
export interface LeMultiselectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeMultiselectElement;
}
export interface LeNumberInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeNumberInputElement;
}
export interface LePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLePopoverElement;
}
export interface LePopupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLePopupElement;
}
export interface LeRichTextEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeRichTextEditorElement;
}
export interface LeSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSelectElement;
}
export interface LeSlotCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeSlotElement;
}
export interface LeStringInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeStringInputElement;
}
export interface LeTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLeTagElement;
}
declare global {
    interface HTMLLeBlockMenuElementEventMap {
        "leBlockTypeSelect": { type: BlockType; config: BlockTypeConfig };
        "leMenuClose": void;
    }
    /**
     * Block menu (command palette) for the rich text editor.
     * Triggered by "/" at the start of a block or clicking the block type icon.
     * @cmsInternal true
     */
    interface HTMLLeBlockMenuElement extends Components.LeBlockMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeBlockMenuElementEventMap>(type: K, listener: (this: HTMLLeBlockMenuElement, ev: LeBlockMenuCustomEvent<HTMLLeBlockMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeBlockMenuElementEventMap>(type: K, listener: (this: HTMLLeBlockMenuElement, ev: LeBlockMenuCustomEvent<HTMLLeBlockMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeBlockMenuElement: {
        prototype: HTMLLeBlockMenuElement;
        new (): HTMLLeBlockMenuElement;
    };
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeBoxElement extends Components.LeBox, HTMLStencilElement {
    }
    var HTMLLeBoxElement: {
        prototype: HTMLLeBoxElement;
        new (): HTMLLeBoxElement;
    };
    interface HTMLLeButtonElementEventMap {
        "click": PointerEvent;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface HTMLLeButtonElement extends Components.LeButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeButtonElementEventMap>(type: K, listener: (this: HTMLLeButtonElement, ev: LeButtonCustomEvent<HTMLLeButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeButtonElementEventMap>(type: K, listener: (this: HTMLLeButtonElement, ev: LeButtonCustomEvent<HTMLLeButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeButtonElement: {
        prototype: HTMLLeButtonElement;
        new (): HTMLLeButtonElement;
    };
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeCardElement extends Components.LeCard, HTMLStencilElement {
    }
    var HTMLLeCardElement: {
        prototype: HTMLLeCardElement;
        new (): HTMLLeCardElement;
    };
    interface HTMLLeCheckboxElementEventMap {
        "change": { checked: boolean; value: string; name: string; externalId: string };
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface HTMLLeCheckboxElement extends Components.LeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeCheckboxElementEventMap>(type: K, listener: (this: HTMLLeCheckboxElement, ev: LeCheckboxCustomEvent<HTMLLeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeCheckboxElementEventMap>(type: K, listener: (this: HTMLLeCheckboxElement, ev: LeCheckboxCustomEvent<HTMLLeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeCheckboxElement: {
        prototype: HTMLLeCheckboxElement;
        new (): HTMLLeCheckboxElement;
    };
    interface HTMLLeComboboxElementEventMap {
        "leChange": LeOptionSelectDetail;
        "leInput": { value: string };
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface HTMLLeComboboxElement extends Components.LeCombobox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeComboboxElementEventMap>(type: K, listener: (this: HTMLLeComboboxElement, ev: LeComboboxCustomEvent<HTMLLeComboboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeComboboxElementEventMap>(type: K, listener: (this: HTMLLeComboboxElement, ev: LeComboboxCustomEvent<HTMLLeComboboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeComboboxElement: {
        prototype: HTMLLeComboboxElement;
        new (): HTMLLeComboboxElement;
    };
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeComponentElement extends Components.LeComponent, HTMLStencilElement {
    }
    var HTMLLeComponentElement: {
        prototype: HTMLLeComponentElement;
        new (): HTMLLeComponentElement;
    };
    interface HTMLLeDropdownBaseElementEventMap {
        "leOptionSelect": LeOptionSelectDetail;
        "leDropdownOpen": void;
        "leDropdownClose": void;
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeDropdownBaseElement extends Components.LeDropdownBase, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeDropdownBaseElementEventMap>(type: K, listener: (this: HTMLLeDropdownBaseElement, ev: LeDropdownBaseCustomEvent<HTMLLeDropdownBaseElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeDropdownBaseElementEventMap>(type: K, listener: (this: HTMLLeDropdownBaseElement, ev: LeDropdownBaseCustomEvent<HTMLLeDropdownBaseElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeDropdownBaseElement: {
        prototype: HTMLLeDropdownBaseElement;
        new (): HTMLLeDropdownBaseElement;
    };
    interface HTMLLeEditorBlockElementEventMap {
        "leBlockChange": { block: LeBlock; content: string };
        "leBlockEnter": { block: LeBlock; cursorAtEnd: boolean };
        "leBlockBackspace": { block: LeBlock };
        "leBlockDelete": { block: LeBlock };
        "leBlockNavigateUp": { block: LeBlock };
        "leBlockNavigateDown": { block: LeBlock };
        "leBlockTypeChange": { block: LeBlock; newType: BlockType };
        "leBlockMenuOpen": {
    block: LeBlock;
    position: { x: number; y: number };
    anchor?: HTMLElement;
  };
        "leBlockFocus": { block: LeBlock };
        "leBlockBlur": { block: LeBlock };
        "leBlockSelection": {
    block: LeBlock;
    hasSelection: boolean;
    range?: Range;
    rect?: DOMRect;
  };
        "leBlockDragStart": { block: LeBlock };
    }
    /**
     * Internal component representing a single block in the rich text editor.
     * @cmsInternal true
     */
    interface HTMLLeEditorBlockElement extends Components.LeEditorBlock, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeEditorBlockElementEventMap>(type: K, listener: (this: HTMLLeEditorBlockElement, ev: LeEditorBlockCustomEvent<HTMLLeEditorBlockElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeEditorBlockElementEventMap>(type: K, listener: (this: HTMLLeEditorBlockElement, ev: LeEditorBlockCustomEvent<HTMLLeEditorBlockElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeEditorBlockElement: {
        prototype: HTMLLeEditorBlockElement;
        new (): HTMLLeEditorBlockElement;
    };
    interface HTMLLeFormatToolbarElementEventMap {
        "leFormat": { format: FormatType };
        "leLinkRequest": void;
    }
    /**
     * Floating format toolbar for text selection in the rich text editor.
     * Positions itself above the selection.
     * @cmsInternal true
     */
    interface HTMLLeFormatToolbarElement extends Components.LeFormatToolbar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeFormatToolbarElementEventMap>(type: K, listener: (this: HTMLLeFormatToolbarElement, ev: LeFormatToolbarCustomEvent<HTMLLeFormatToolbarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeFormatToolbarElementEventMap>(type: K, listener: (this: HTMLLeFormatToolbarElement, ev: LeFormatToolbarCustomEvent<HTMLLeFormatToolbarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeFormatToolbarElement: {
        prototype: HTMLLeFormatToolbarElement;
        new (): HTMLLeFormatToolbarElement;
    };
    interface HTMLLeMultiselectElementEventMap {
        "leChange": LeMultiOptionSelectDetail;
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface HTMLLeMultiselectElement extends Components.LeMultiselect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeMultiselectElementEventMap>(type: K, listener: (this: HTMLLeMultiselectElement, ev: LeMultiselectCustomEvent<HTMLLeMultiselectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeMultiselectElementEventMap>(type: K, listener: (this: HTMLLeMultiselectElement, ev: LeMultiselectCustomEvent<HTMLLeMultiselectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeMultiselectElement: {
        prototype: HTMLLeMultiselectElement;
        new (): HTMLLeMultiselectElement;
    };
    interface HTMLLeNumberInputElementEventMap {
        "leChange": { value: number; name: string; externalId: string; isValid: boolean };
        "leInput": { value: number; name: string; externalId: string; isValid: boolean };
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface HTMLLeNumberInputElement extends Components.LeNumberInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeNumberInputElementEventMap>(type: K, listener: (this: HTMLLeNumberInputElement, ev: LeNumberInputCustomEvent<HTMLLeNumberInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeNumberInputElementEventMap>(type: K, listener: (this: HTMLLeNumberInputElement, ev: LeNumberInputCustomEvent<HTMLLeNumberInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeNumberInputElement: {
        prototype: HTMLLeNumberInputElement;
        new (): HTMLLeNumberInputElement;
    };
    interface HTMLLePopoverElementEventMap {
        "lePopoverOpen": void;
        "lePopoverClose": void;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLePopoverElement extends Components.LePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLePopoverElementEventMap>(type: K, listener: (this: HTMLLePopoverElement, ev: LePopoverCustomEvent<HTMLLePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLePopoverElementEventMap>(type: K, listener: (this: HTMLLePopoverElement, ev: LePopoverCustomEvent<HTMLLePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLePopoverElement: {
        prototype: HTMLLePopoverElement;
        new (): HTMLLePopoverElement;
    };
    interface HTMLLePopupElementEventMap {
        "leConfirm": PopupResult;
        "leCancel": PopupResult;
        "leOpen": void;
        "leClose": PopupResult;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically 
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLePopupElement extends Components.LePopup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLePopupElementEventMap>(type: K, listener: (this: HTMLLePopupElement, ev: LePopupCustomEvent<HTMLLePopupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLePopupElementEventMap>(type: K, listener: (this: HTMLLePopupElement, ev: LePopupCustomEvent<HTMLLePopupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLePopupElement: {
        prototype: HTMLLePopupElement;
        new (): HTMLLePopupElement;
    };
    interface HTMLLeRichTextEditorElementEventMap {
        "leChange": LeBlockChangeDetail;
        "leBlockAdd": LeBlock;
        "leBlockRemove": LeBlock;
        "leFocus": void;
        "leBlur": void;
    }
    /**
     * Rich text editor with block-based editing, similar to Notion.
     * Features:
     * - Block-based content structure (paragraphs, headings, lists, quotes, code, dividers)
     * - Markdown shortcuts (# for headings, - for lists, > for quotes, etc.)
     * - Inline formatting toolbar (bold, italic, underline, strikethrough, code, links)
     * - Block command menu triggered by /
     * - Drag and drop block reordering
     * - HTML and Markdown export
     * @cmsEditable true
     * @cmsCategory Content
     * @example Basic usage
     * ```html
     * <le-rich-text-editor placeholder="Start writing..."></le-rich-text-editor>
     * ```
     * @example With initial content
     * ```html
     * <le-rich-text-editor id="editor"></le-rich-text-editor>
     * <script>
     * const editor = document.getElementById('editor');
     * editor.setHtml('<h1>Hello</h1><p>World</p>');
     * </script>
     * ```
     */
    interface HTMLLeRichTextEditorElement extends Components.LeRichTextEditor, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeRichTextEditorElementEventMap>(type: K, listener: (this: HTMLLeRichTextEditorElement, ev: LeRichTextEditorCustomEvent<HTMLLeRichTextEditorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeRichTextEditorElementEventMap>(type: K, listener: (this: HTMLLeRichTextEditorElement, ev: LeRichTextEditorCustomEvent<HTMLLeRichTextEditorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeRichTextEditorElement: {
        prototype: HTMLLeRichTextEditorElement;
        new (): HTMLLeRichTextEditorElement;
    };
    interface HTMLLeRoundProgressElement extends Components.LeRoundProgress, HTMLStencilElement {
    }
    var HTMLLeRoundProgressElement: {
        prototype: HTMLLeRoundProgressElement;
        new (): HTMLLeRoundProgressElement;
    };
    interface HTMLLeSelectElementEventMap {
        "leChange": LeOptionSelectDetail;
        "leOpen": void;
        "leClose": void;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface HTMLLeSelectElement extends Components.LeSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSelectElementEventMap>(type: K, listener: (this: HTMLLeSelectElement, ev: LeSelectCustomEvent<HTMLLeSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSelectElementEventMap>(type: K, listener: (this: HTMLLeSelectElement, ev: LeSelectCustomEvent<HTMLLeSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSelectElement: {
        prototype: HTMLLeSelectElement;
        new (): HTMLLeSelectElement;
    };
    interface HTMLLeSlotElementEventMap {
        "leSlotChange": { name: string; value: string; isValid: boolean };
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface HTMLLeSlotElement extends Components.LeSlot, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeSlotElementEventMap>(type: K, listener: (this: HTMLLeSlotElement, ev: LeSlotCustomEvent<HTMLLeSlotElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeSlotElementEventMap>(type: K, listener: (this: HTMLLeSlotElement, ev: LeSlotCustomEvent<HTMLLeSlotElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeSlotElement: {
        prototype: HTMLLeSlotElement;
        new (): HTMLLeSlotElement;
    };
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface HTMLLeStackElement extends Components.LeStack, HTMLStencilElement {
    }
    var HTMLLeStackElement: {
        prototype: HTMLLeStackElement;
        new (): HTMLLeStackElement;
    };
    interface HTMLLeStringInputElementEventMap {
        "change": {
    value: string;
    name: string;
    externalId: string;
  };
        "input": {
    value: string;
    name: string;
    externalId: string;
  };
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface HTMLLeStringInputElement extends Components.LeStringInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeStringInputElementEventMap>(type: K, listener: (this: HTMLLeStringInputElement, ev: LeStringInputCustomEvent<HTMLLeStringInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeStringInputElementEventMap>(type: K, listener: (this: HTMLLeStringInputElement, ev: LeStringInputCustomEvent<HTMLLeStringInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeStringInputElement: {
        prototype: HTMLLeStringInputElement;
        new (): HTMLLeStringInputElement;
    };
    interface HTMLLeTagElementEventMap {
        "leDismiss": void;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface HTMLLeTagElement extends Components.LeTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLeTagElementEventMap>(type: K, listener: (this: HTMLLeTagElement, ev: LeTagCustomEvent<HTMLLeTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLeTagElementEventMap>(type: K, listener: (this: HTMLLeTagElement, ev: LeTagCustomEvent<HTMLLeTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLeTagElement: {
        prototype: HTMLLeTagElement;
        new (): HTMLLeTagElement;
    };
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface HTMLLeTextElement extends Components.LeText, HTMLStencilElement {
    }
    var HTMLLeTextElement: {
        prototype: HTMLLeTextElement;
        new (): HTMLLeTextElement;
    };
    interface HTMLLeTurntableElement extends Components.LeTurntable, HTMLStencilElement {
    }
    var HTMLLeTurntableElement: {
        prototype: HTMLLeTurntableElement;
        new (): HTMLLeTurntableElement;
    };
    interface HTMLElementTagNameMap {
        "le-block-menu": HTMLLeBlockMenuElement;
        "le-box": HTMLLeBoxElement;
        "le-button": HTMLLeButtonElement;
        "le-card": HTMLLeCardElement;
        "le-checkbox": HTMLLeCheckboxElement;
        "le-combobox": HTMLLeComboboxElement;
        "le-component": HTMLLeComponentElement;
        "le-dropdown-base": HTMLLeDropdownBaseElement;
        "le-editor-block": HTMLLeEditorBlockElement;
        "le-format-toolbar": HTMLLeFormatToolbarElement;
        "le-multiselect": HTMLLeMultiselectElement;
        "le-number-input": HTMLLeNumberInputElement;
        "le-popover": HTMLLePopoverElement;
        "le-popup": HTMLLePopupElement;
        "le-rich-text-editor": HTMLLeRichTextEditorElement;
        "le-round-progress": HTMLLeRoundProgressElement;
        "le-select": HTMLLeSelectElement;
        "le-slot": HTMLLeSlotElement;
        "le-stack": HTMLLeStackElement;
        "le-string-input": HTMLLeStringInputElement;
        "le-tag": HTMLLeTagElement;
        "le-text": HTMLLeTextElement;
        "le-turntable": HTMLLeTurntableElement;
    }
}
declare namespace LocalJSX {
    /**
     * Block menu (command palette) for the rich text editor.
     * Triggered by "/" at the start of a block or clicking the block type icon.
     * @cmsInternal true
     */
    interface LeBlockMenu {
        /**
          * Available block types.
          * @default DEFAULT_BLOCK_CONFIGS
         */
        "blockTypes"?: BlockTypeConfig[];
        /**
          * Emitted when a block type is selected.
         */
        "onLeBlockTypeSelect"?: (event: LeBlockMenuCustomEvent<{ type: BlockType; config: BlockTypeConfig }>) => void;
        /**
          * Emitted when the menu is closed.
         */
        "onLeMenuClose"?: (event: LeBlockMenuCustomEvent<void>) => void;
        /**
          * Whether the menu is visible.
          * @default false
         */
        "open"?: boolean;
        /**
          * Position to show the menu at.
          * @default { x: 0, y: 0 }
         */
        "position"?: { x: number; y: number };
    }
    /**
     * A flexible box component for use as a flex item within le-stack.
     * `le-box` wraps content and provides flex item properties like grow, shrink,
     * basis, and self-alignment. It can also control its internal content alignment.
     * @cssprop --le-box-bg - Background color
     * @cssprop --le-box-padding - Padding inside the box
     * @cssprop --le-box-border-radius - Border radius
     * @csspart box - The main box container
     * @csspart content - The inner content wrapper
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeBox {
        /**
          * Internal horizontal alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'stretch'
         */
        "alignContent"?: 'start' | 'center' | 'end' | 'stretch';
        /**
          * Self-alignment override for this item on the cross axis
          * @allowedValues auto | start | center | end | stretch | baseline
          * @default 'auto'
         */
        "alignSelf"?: 'auto' | 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Background color or CSS value (e.g., '#f0f0f0', 'var(--le-color-primary-light)')
         */
        "background"?: string;
        /**
          * Flex basis - initial size before growing/shrinking (e.g., '200px', '25%', 'auto')
          * @default 'auto'
         */
        "basis"?: string;
        /**
          * Border style (e.g., '1px solid #ccc', '2px dashed var(--le-color-border)')
         */
        "border"?: string;
        /**
          * Border radius (e.g., '8px', 'var(--le-radius-md)')
         */
        "borderRadius"?: string;
        /**
          * Whether to display box content as flex (for internal alignment)
          * @default false
         */
        "displayFlex"?: boolean;
        /**
          * Flex grow factor - how much the item should grow relative to siblings
          * @min 0
          * @default 0
         */
        "grow"?: number;
        /**
          * Height of the box (CSS value)
         */
        "height"?: string;
        /**
          * Direction of internal flex layout when displayFlex is true
          * @allowedValues horizontal | vertical
          * @default 'vertical'
         */
        "innerDirection"?: 'horizontal' | 'vertical';
        /**
          * Gap between internal flex items when displayFlex is true
         */
        "innerGap"?: string;
        /**
          * Internal vertical alignment of content
          * @allowedValues start | center | end | stretch
          * @default 'start'
         */
        "justifyContent"?: 'start' | 'center' | 'end' | 'stretch';
        /**
          * Maximum height constraint
         */
        "maxHeight"?: string;
        /**
          * Maximum width constraint
         */
        "maxWidth"?: string;
        /**
          * Minimum height constraint
         */
        "minHeight"?: string;
        /**
          * Minimum width constraint
         */
        "minWidth"?: string;
        /**
          * Order in the flex container (lower values come first)
         */
        "order"?: number;
        /**
          * Padding inside the box (CSS value like '8px', '1rem')
         */
        "padding"?: string;
        /**
          * Flex shrink factor - how much the item should shrink relative to siblings
          * @min 0
          * @default 1
         */
        "shrink"?: number;
        /**
          * Width of the box (CSS value like '100px', '50%', 'auto')
         */
        "width"?: string;
    }
    /**
     * A flexible button component with multiple variants and states.
     * @cssprop --le-button-bg - Button background color
     * @cssprop --le-button-color - Button text color
     * @cssprop --le-button-border-radius - Button border radius
     * @cssprop --le-button-padding-x - Button horizontal padding
     * @cssprop --le-button-padding-y - Button vertical padding
     * @csspart button - The native button element
     * @csspart content - The button content wrapper
     * @csspart icon-start - The start icon slot
     * @csspart icon-end - The end icon slot
     * @cmsEditable true
     * @cmsCategory Actions
     */
    interface LeButton {
        /**
          * Alignment of the button label without the end icon
          * @allowedValues start | center | space-between | end
          * @default 'center'
         */
        "align"?: 'start' | 'center' | 'space-between' | 'end';
        /**
          * Button color theme (uses theme semantic colors)
          * @allowedValues primary | secondary | success | warning | danger | info
          * @default 'primary'
         */
        "color"?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';
        /**
          * Whether the button is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the button takes full width of its container
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Optional href to make the button act as a link
         */
        "href"?: string;
        /**
          * End icon image or emoji
         */
        "iconEnd"?: string | Node;
        /**
          * Icon only button image or emoji if this prop is set, the button will render only the icon slot
         */
        "iconOnly"?: string | Node;
        /**
          * Start icon image or emoji
         */
        "iconStart"?: string | Node;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Emitted when the button is clicked. This is a custom event that wraps the native click but ensures the target is the le-button.
         */
        "onClick"?: (event: LeButtonCustomEvent<PointerEvent>) => void;
        /**
          * Whether the button is in a selected/active state
          * @default false
         */
        "selected"?: boolean;
        /**
          * Button size
          * @allowedValues small | medium | large
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * Link target when href is set
         */
        "target"?: string;
        /**
          * The button type attribute
          * @allowedValues button | submit | reset
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * Button variant style
          * @allowedValues solid | outlined | clear
          * @default 'solid'
         */
        "variant"?: 'solid' | 'outlined' | 'clear' | 'system';
    }
    /**
     * A flexible card component with header, content, and footer slots.
     * The card uses le-slot wrappers for each slot area. In admin mode,
     * le-slot shows placeholders for CMS editing. In default mode,
     * le-slot acts as a transparent passthrough.
     * @cssprop --le-card-bg - Card background color
     * @cssprop --le-card-border-radius - Card border radius
     * @cssprop --le-card-shadow - Card box shadow
     * @cssprop --le-card-padding - Card content padding
     * @csspart card - The main card container
     * @csspart header - The card header section
     * @csspart content - The card content section
     * @csspart footer - The card footer section
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeCard {
        /**
          * Whether the card is interactive (clickable)
          * @default false
         */
        "interactive"?: boolean;
        /**
          * Card variant style
          * @allowedValues default | outlined | elevated
          * @default 'default'
         */
        "variant"?: 'default' | 'outlined' | 'elevated';
    }
    /**
     * A checkbox component with support for labels, descriptions, and external IDs.
     * @cssprop --le-checkbox-size - Size of the checkbox input
     * @cssprop --le-checkbox-color - Color of the checkbox when checked
     * @cssprop --le-checkbox-label-color - Color of the label text
     * @cssprop --le-checkbox-desc-color - Color of the description text
     */
    interface LeCheckbox {
        /**
          * Whether the checkbox is checked
          * @default false
         */
        "checked"?: boolean;
        /**
          * Whether the checkbox is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems (e.g. database ID, PDF form field ID)
         */
        "externalId"?: string;
        /**
          * The name of the checkbox input
         */
        "name"?: string;
        /**
          * Emitted when the checked state changes
         */
        "onChange"?: (event: LeCheckboxCustomEvent<{ checked: boolean; value: string; name: string; externalId: string }>) => void;
        /**
          * The value of the checkbox input
         */
        "value"?: string;
    }
    /**
     * A combobox component with searchable dropdown.
     * Combines a text input with a dropdown list, allowing users to
     * filter options by typing or select from the list.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic combobox
     * ```html
     * <le-combobox
     * placeholder="Search..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-combobox>
     * ```
     * @example Allow custom values
     * ```html
     * <le-combobox
     * placeholder="Type or select..."
     * allow-custom
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-combobox>
     * ```
     */
    interface LeCombobox {
        /**
          * Whether to allow custom values not in the options list.
          * @default false
         */
        "allowCustom"?: boolean;
        /**
          * Whether the combobox is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Minimum characters before showing filtered results.
          * @default 0
         */
        "minSearchLength"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected value changes.
         */
        "onLeChange"?: (event: LeComboboxCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeComboboxCustomEvent<void>) => void;
        /**
          * Emitted when the input value changes (for custom values).
         */
        "onLeInput"?: (event: LeComboboxCustomEvent<{ value: string }>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeComboboxCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text for the input.
          * @default 'Type to search...'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Size variant of the combobox.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
    }
    /**
     * Component wrapper for admin mode editing.
     * This component is used internally by other components to provide admin-mode
     * editing capabilities. It wraps the component's rendered output and shows
     * a settings popover for editing properties.
     * In default mode, it acts as a simple passthrough (display: contents).
     * In admin mode, it shows a border, component name header, and settings popover.
     * The host element is found automatically by traversing up through the shadow DOM.
     * Usage inside a component's render method:
     * ```tsx
     * render() {
     *   return (
     *     <le-component component="le-card">
     *       <Host>...</Host>
     *     </le-component>
     *   );
     * }
     * ```
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeComponent {
        /**
          * The tag name of the component (e.g., 'le-card'). Used to look up property metadata and display the component name.
         */
        "component": string;
        /**
          * Optional display name for the component. If not provided, the tag name will be formatted as the display name.
         */
        "displayName"?: string;
        /**
          * Classes to apply to the host element. Allows parent components to pass their styling classes.
         */
        "hostClass"?: string;
        /**
          * Inline styles to apply to the host element. Allows parent components to pass dynamic styles (e.g., flex properties).
         */
        "hostStyle"?: { [key: string]: string };
    }
    /**
     * Internal dropdown base component that provides shared functionality
     * for select, combobox, and multiselect components.
     * Wraps le-popover for positioning and provides:
     * - Option list rendering with groups
     * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
     * - Option filtering support
     * - Single and multi-select modes
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeDropdownBase {
        /**
          * Whether to close the dropdown when clicking outside. (used to support combobox with input focus)
          * @default true
         */
        "closeOnClickOutside"?: boolean;
        /**
          * Whether the dropdown is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Placeholder text when no options match filter.
          * @default 'No options'
         */
        "emptyText"?: string;
        /**
          * Filter function for options. Return true to include the option.
         */
        "filterFn"?: (option: LeOption, query: string) => boolean;
        /**
          * Current filter query string.
          * @default ''
         */
        "filterQuery"?: string;
        /**
          * Sets the dropdown to full width of the trigger.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Maximum height of the dropdown list.
          * @default '300px'
         */
        "maxHeight"?: string;
        /**
          * Whether multiple selection is allowed.
          * @default false
         */
        "multiple"?: boolean;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeDropdownClose"?: (event: LeDropdownBaseCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeDropdownOpen"?: (event: LeDropdownBaseCustomEvent<void>) => void;
        /**
          * Emitted when an option is selected.
         */
        "onLeOptionSelect"?: (event: LeDropdownBaseCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Whether the dropdown is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[];
        /**
          * Whether to show checkboxes for multiselect mode.
          * @default true
         */
        "showCheckboxes"?: boolean;
        /**
          * Current value(s) - single value or array for multiselect.
         */
        "value"?: LeOptionValue | LeOptionValue[];
        /**
          * Width of the dropdown. If not set, matches trigger width.
         */
        "width"?: string;
    }
    /**
     * Internal component representing a single block in the rich text editor.
     * @cmsInternal true
     */
    interface LeEditorBlock {
        /**
          * The block data.
         */
        "block"?: LeBlock;
        /**
          * Whether this block is currently focused.
          * @default false
         */
        "focused"?: boolean;
        /**
          * For numbered lists, which number to start at (1-based).
          * @default 1
         */
        "listStart"?: number;
        /**
          * Emitted when Backspace is pressed at start of block.
         */
        "onLeBlockBackspace"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when block loses focus.
         */
        "onLeBlockBlur"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when the block content changes.
         */
        "onLeBlockChange"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock; content: string }>) => void;
        /**
          * Emitted when Delete is pressed at end of block.
         */
        "onLeBlockDelete"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when drag handle is grabbed.
         */
        "onLeBlockDragStart"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when Enter is pressed (request new block).
         */
        "onLeBlockEnter"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock; cursorAtEnd: boolean }>) => void;
        /**
          * Emitted when block requests focus.
         */
        "onLeBlockFocus"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when block menu should open (via icon click or "/").
         */
        "onLeBlockMenuOpen"?: (event: LeEditorBlockCustomEvent<{
    block: LeBlock;
    position: { x: number; y: number };
    anchor?: HTMLElement;
  }>) => void;
        /**
          * Emitted when arrow down is pressed at end.
         */
        "onLeBlockNavigateDown"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when arrow up is pressed at start.
         */
        "onLeBlockNavigateUp"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock }>) => void;
        /**
          * Emitted when text is selected (for showing format toolbar).
         */
        "onLeBlockSelection"?: (event: LeEditorBlockCustomEvent<{
    block: LeBlock;
    hasSelection: boolean;
    range?: Range;
    rect?: DOMRect;
  }>) => void;
        /**
          * Emitted when block type should change (via markdown shortcut).
         */
        "onLeBlockTypeChange"?: (event: LeEditorBlockCustomEvent<{ block: LeBlock; newType: BlockType }>) => void;
        /**
          * Whether the editor is in readonly mode.
          * @default false
         */
        "readonly"?: boolean;
    }
    /**
     * Floating format toolbar for text selection in the rich text editor.
     * Positions itself above the selection.
     * @cmsInternal true
     */
    interface LeFormatToolbar {
        /**
          * Currently active formats.
          * @default []
         */
        "activeFormats"?: FormatType[];
        /**
          * Which format buttons to show.
          * @default ['bold', 'italic', 'underline', 'strikethrough', 'code', 'link']
         */
        "formats"?: FormatType[];
        /**
          * Emitted when a format button is clicked.
         */
        "onLeFormat"?: (event: LeFormatToolbarCustomEvent<{ format: FormatType }>) => void;
        /**
          * Emitted when link button is clicked (needs special handling).
         */
        "onLeLinkRequest"?: (event: LeFormatToolbarCustomEvent<void>) => void;
        /**
          * Whether the toolbar is visible.
          * @default false
         */
        "open"?: boolean;
        /**
          * Position to show the toolbar at (center-x, top-y of selection).
          * @default { x: 0, y: 0 }
         */
        "position"?: { x: number; y: number };
    }
    /**
     * A multiselect component for selecting multiple options.
     * Displays selected items as tags with optional search filtering.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic multiselect
     * ```html
     * <le-multiselect
     * placeholder="Select options..."
     * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
     * ></le-multiselect>
     * ```
     * @example With max selections
     * ```html
     * <le-multiselect
     * max-selections="3"
     * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
     * ></le-multiselect>
     * ```
     * @example With search
     * ```html
     * <le-multiselect
     * searchable
     * placeholder="Search and select..."
     * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
     * ></le-multiselect>
     * ```
     */
    interface LeMultiselect {
        /**
          * Whether the multiselect is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the multiselect should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Maximum number of selections allowed.
         */
        "maxSelections"?: number;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected values change.
         */
        "onLeChange"?: (event: LeMultiselectCustomEvent<LeMultiOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeMultiselectCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeMultiselectCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text when no options are selected.
          * @default 'Select options...'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable"?: boolean;
        /**
          * Whether to show a "Select All" option. Also accepts a string or array of strings to customize the label(s).
          * @default false
         */
        "showSelectAll"?: boolean | string | string[];
        /**
          * Size variant of the multiselect.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected values.
          * @default []
         */
        "value"?: LeOptionValue[];
    }
    /**
     * A number input component with validation, keyboard controls, and custom spinners.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-border-error - Input border style when invalid
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeNumberInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId"?: string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Label for the input
         */
        "label"?: string;
        /**
          * Maximum allowed value
         */
        "max"?: number;
        /**
          * Minimum allowed value
         */
        "min"?: number;
        /**
          * The name of the input
         */
        "name"?: string;
        /**
          * Emitted when the value changes (on blur or Enter)
         */
        "onLeChange"?: (event: LeNumberInputCustomEvent<{ value: number; name: string; externalId: string; isValid: boolean }>) => void;
        /**
          * Emitted when the input value changes (on keystroke/spin)
         */
        "onLeInput"?: (event: LeNumberInputCustomEvent<{ value: number; name: string; externalId: string; isValid: boolean }>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Whether the input is required
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether to show the spinner controls
          * @default true
         */
        "showSpinners"?: boolean;
        /**
          * Step value for increment/decrement
          * @default 1
         */
        "step"?: number;
        /**
          * The value of the input
         */
        "value"?: number;
    }
    /**
     * A popover component for displaying floating content.
     * Uses the native HTML Popover API for proper layering with dialogs
     * and other top-layer elements. Falls back gracefully in older browsers.
     * @csspart trigger - The popover trigger element
     * @csspart content - The popover content wrapper
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopover {
        /**
          * Alignment of the popover
          * @default 'start'
         */
        "align"?: 'start' | 'center' | 'end';
        /**
          * Whether clicking outside closes the popover
          * @default true
         */
        "closeOnClickOutside"?: boolean;
        /**
          * Whether pressing Escape closes the popover
          * @default true
         */
        "closeOnEscape"?: boolean;
        /**
          * Maximum width for the popover (e.g., '400px', '25rem')
         */
        "maxWidth"?: string;
        /**
          * Minimum width for the popover (e.g., '200px', '15rem')
          * @default '200px'
         */
        "minWidth"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Offset from the trigger element (in pixels)
          * @default 8
         */
        "offset"?: number;
        /**
          * Emitted when the popover closes
         */
        "onLePopoverClose"?: (event: LePopoverCustomEvent<void>) => void;
        /**
          * Emitted when the popover opens
         */
        "onLePopoverOpen"?: (event: LePopoverCustomEvent<void>) => void;
        /**
          * Whether the popover is currently open
          * @default false
         */
        "open"?: boolean;
        /**
          * Optional title for the popover header
         */
        "popoverTitle"?: string;
        /**
          * Position of the popover relative to its trigger
          * @default 'bottom'
         */
        "position"?: 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Whether to show a close button in the header
          * @default true
         */
        "showClose"?: boolean;
        /**
          * Should the popover's trigger take full width of its container
          * @default false
         */
        "triggerFullWidth"?: boolean;
        /**
          * Fixed width for the popover (e.g., '300px', '20rem')
         */
        "width"?: string;
    }
    /**
     * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
     * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
     * and focus management. Can be used declaratively in HTML or programmatically 
     * via leAlert(), leConfirm(), lePrompt().
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LePopup {
        /**
          * Text for the cancel button
          * @default 'Cancel'
         */
        "cancelText"?: string;
        /**
          * Whether clicking the backdrop closes the popup (modal only)
          * @default true
         */
        "closeOnBackdrop"?: boolean;
        /**
          * Text for the confirm/OK button
          * @default 'OK'
         */
        "confirmText"?: string;
        /**
          * Default value for prompt input
          * @default ''
         */
        "defaultValue"?: string;
        /**
          * Message text to display (for alert/confirm/prompt types)
         */
        "message"?: string;
        /**
          * Whether the popup is modal (blocks interaction with page behind)
          * @default true
         */
        "modal"?: boolean;
        /**
          * Emitted when the popup is cancelled (Cancel clicked or dismissed)
         */
        "onLeCancel"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup closes
         */
        "onLeClose"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup is confirmed (OK clicked)
         */
        "onLeConfirm"?: (event: LePopupCustomEvent<PopupResult>) => void;
        /**
          * Emitted when the popup opens
         */
        "onLeOpen"?: (event: LePopupCustomEvent<void>) => void;
        /**
          * Whether the popup is currently visible
          * @default false
         */
        "open"?: boolean;
        /**
          * Placeholder text for prompt input
          * @default ''
         */
        "placeholder"?: string;
        /**
          * Optional title for the popup header
         */
        "popupTitle"?: string;
        /**
          * Position of the popup on screen
          * @default 'center'
         */
        "position"?: PopupPosition;
        /**
          * Type of popup: alert (OK only), confirm (OK/Cancel), prompt (input + OK/Cancel), custom
          * @default 'alert'
         */
        "type"?: PopupType;
    }
    /**
     * Rich text editor with block-based editing, similar to Notion.
     * Features:
     * - Block-based content structure (paragraphs, headings, lists, quotes, code, dividers)
     * - Markdown shortcuts (# for headings, - for lists, > for quotes, etc.)
     * - Inline formatting toolbar (bold, italic, underline, strikethrough, code, links)
     * - Block command menu triggered by /
     * - Drag and drop block reordering
     * - HTML and Markdown export
     * @cmsEditable true
     * @cmsCategory Content
     * @example Basic usage
     * ```html
     * <le-rich-text-editor placeholder="Start writing..."></le-rich-text-editor>
     * ```
     * @example With initial content
     * ```html
     * <le-rich-text-editor id="editor"></le-rich-text-editor>
     * <script>
     * const editor = document.getElementById('editor');
     * editor.setHtml('<h1>Hello</h1><p>World</p>');
     * </script>
     * ```
     */
    interface LeRichTextEditor {
        /**
          * Whether to autofocus on mount.
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * Available block types.
          * @default DEFAULT_BLOCK_CONFIGS
         */
        "blockTypes"?: BlockTypeConfig[];
        /**
          * Maximum height (scrollable).
         */
        "maxHeight"?: string;
        /**
          * Minimum height of the editor.
         */
        "minHeight"?: string;
        /**
          * Emitted when a block is added.
         */
        "onLeBlockAdd"?: (event: LeRichTextEditorCustomEvent<LeBlock>) => void;
        /**
          * Emitted when a block is removed.
         */
        "onLeBlockRemove"?: (event: LeRichTextEditorCustomEvent<LeBlock>) => void;
        /**
          * Emitted when editor loses focus.
         */
        "onLeBlur"?: (event: LeRichTextEditorCustomEvent<void>) => void;
        /**
          * Emitted when content changes.
         */
        "onLeChange"?: (event: LeRichTextEditorCustomEvent<LeBlockChangeDetail>) => void;
        /**
          * Emitted when editor gains focus.
         */
        "onLeFocus"?: (event: LeRichTextEditorCustomEvent<void>) => void;
        /**
          * Placeholder text shown in empty editor.
          * @default "Type '/' for commands..."
         */
        "placeholder"?: string;
        /**
          * Whether the editor is in readonly mode.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Initial HTML content.
         */
        "value"?: string;
    }
    interface LeRoundProgress {
        /**
          * @default 0
         */
        "padding"?: number;
        "paths"?: string;
        /**
          * @default 0
         */
        "value"?: number;
    }
    /**
     * A select dropdown component for single selection.
     * @cmsEditable true
     * @cmsCategory Form
     * @example Basic select
     * ```html
     * <le-select
     * placeholder="Choose an option"
     * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
     * ></le-select>
     * ```
     * @example With icons
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
     * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
     * ]'
     * ></le-select>
     * ```
     * @example Grouped options
     * ```html
     * <le-select
     * options='[
     * {"label": "Apple", "value": "apple", "group": "Fruits"},
     * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
     * ]'
     * ></le-select>
     * ```
     */
    interface LeSelect {
        /**
          * Whether the select is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text to show when no options match the search.
          * @default 'No results found'
         */
        "emptyText"?: string;
        /**
          * Whether the select should take full width of its container.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Name attribute for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the selected value changes.
         */
        "onLeChange"?: (event: LeSelectCustomEvent<LeOptionSelectDetail>) => void;
        /**
          * Emitted when the dropdown closes.
         */
        "onLeClose"?: (event: LeSelectCustomEvent<void>) => void;
        /**
          * Emitted when the dropdown opens.
         */
        "onLeOpen"?: (event: LeSelectCustomEvent<void>) => void;
        /**
          * Whether the dropdown is currently open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The options to display in the dropdown.
          * @default []
         */
        "options"?: LeOption[] | string;
        /**
          * Placeholder text when no option is selected.
          * @default 'Select an option'
         */
        "placeholder"?: string;
        /**
          * Whether selection is required.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether the input is searchable.
          * @default false
         */
        "searchable"?: boolean;
        /**
          * Size variant of the select.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The currently selected value.
         */
        "value"?: LeOptionValue;
        /**
          * Visual variant of the select.
          * @default 'default'
         */
        "variant"?: 'default' | 'outlined' | 'solid';
    }
    /**
     * Slot placeholder component for admin/CMS mode.
     * This component renders a visual placeholder for slots when in admin mode,
     * allowing CMS systems to show available drop zones for content or inline editing.
     * In non-admin mode, this component renders nothing and acts as a passthrough.
     * @cmsInternal true
     * @cmsCategory System
     */
    interface LeSlot {
        /**
          * Comma-separated list of allowed component tags for this slot. Used by CMS to filter available components.
          * @example "le-card,le-button,le-text"
         */
        "allowedComponents"?: string;
        /**
          * Description of what content this slot accepts. Shown in admin mode to guide content editors.
         */
        "description"?: string;
        /**
          * Label to display in admin mode. If not provided, the slot name will be used.
         */
        "label"?: string;
        /**
          * Whether multiple components can be dropped in this slot.
          * @default true
         */
        "multiple"?: boolean;
        /**
          * The name of the slot this placeholder represents. Should match the slot name in the parent component.
          * @default ''
         */
        "name"?: string;
        /**
          * Emitted when text content changes in admin mode. The event detail contains the new text value and validity.
         */
        "onLeSlotChange"?: (event: LeSlotCustomEvent<{ name: string; value: string; isValid: boolean }>) => void;
        /**
          * Placeholder text for text/textarea inputs in admin mode.
         */
        "placeholder"?: string;
        /**
          * Whether this slot is required to have content.
          * @default false
         */
        "required"?: boolean;
        /**
          * CSS styles for the slot dropzone container. Useful for layouts - e.g., "flex-direction: row" for horizontal stacks. Only applies in admin mode for type="slot".
         */
        "slotStyle"?: string;
        /**
          * The HTML tag to create when there's no slotted element. Used with type="text" or type="textarea" to auto-create elements.
          * @example "h3" - creates <h3 slot="header">content</h3>
          * @example "p" - creates <p slot="content">content</p>
         */
        "tag"?: string;
        /**
          * The type of slot content. - `slot`: Default, shows a dropzone for components (default) - `text`: Shows a single-line text input - `textarea`: Shows a multi-line text area
          * @default 'slot'
         */
        "type"?: 'slot' | 'text' | 'textarea';
    }
    /**
     * A flexible stack layout component using CSS flexbox.
     * `le-stack` arranges its children in a row (horizontal) or column (vertical)
     * with configurable spacing, alignment, and wrapping behavior. Perfect for
     * creating responsive layouts.
     * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
     * @csspart stack - The main stack container
     * @cmsEditable true
     * @cmsCategory Layout
     */
    interface LeStack {
        /**
          * Alignment of items on the cross axis
          * @allowedValues start | center | end | stretch | baseline
          * @default 'stretch'
         */
        "align"?: 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * Alignment of wrapped lines (only applies when wrap is true)
          * @allowedValues start | center | end | stretch | space-between | space-around
          * @default 'stretch'
         */
        "alignContent"?: 'start' | 'center' | 'end' | 'stretch' | 'space-between' | 'space-around';
        /**
          * Direction of the stack layout
          * @allowedValues horizontal | vertical
          * @default 'horizontal'
         */
        "direction"?: 'horizontal' | 'vertical';
        /**
          * Whether the stack should take full height of its container
          * @default false
         */
        "fullHeight"?: boolean;
        /**
          * Whether the stack should take full width of its container
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * Gap between items (CSS value like '8px', '1rem', 'var(--le-space-md)')
         */
        "gap"?: string;
        /**
          * Distribution of items on the main axis
          * @allowedValues start | center | end | space-between | space-around | space-evenly
          * @default 'start'
         */
        "justify"?: 'start' | 'center' | 'end' | 'space-between' | 'space-around' | 'space-evenly';
        /**
          * Maximum number of items allowed in the stack (for CMS validation)
          * @min 1
         */
        "maxItems"?: number;
        /**
          * Padding inside the stack container (CSS value)
         */
        "padding"?: string;
        /**
          * Whether to reverse the order of items
          * @default false
         */
        "reverse"?: boolean;
        /**
          * Whether items should wrap to multiple lines
          * @default false
         */
        "wrap"?: boolean;
    }
    /**
     * A text input component with support for labels, descriptions, icons, and external IDs.
     * @cssprop --le-input-bg - Input background color
     * @cssprop --le-input-color - Input text color
     * @cssprop --le-input-border - Input border style
     * @cssprop --le-input-border-focus - Input border style when focused
     * @cssprop --le-input-radius - Input border radius
     * @cssprop --le-input-padding - Input padding
     */
    interface LeStringInput {
        /**
          * Whether the input is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * External ID for linking with external systems
         */
        "externalId"?: string;
        /**
          * Hide description slot
          * @default false
         */
        "hideDescription"?: boolean;
        /**
          * Icon for the end icon
         */
        "iconEnd"?: string;
        /**
          * Icon for the start icon
         */
        "iconStart"?: string;
        /**
          * Pass the ref of the input element to the parent component
         */
        "inputRef"?: (el: HTMLInputElement) => void;
        /**
          * Label for the input
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * The name of the input
         */
        "name"?: string;
        /**
          * Emitted when the value changes (on blur or Enter)
         */
        "onChange"?: (event: LeStringInputCustomEvent<{
    value: string;
    name: string;
    externalId: string;
  }>) => void;
        /**
          * Emitted when the input value changes (on keystroke)
         */
        "onInput"?: (event: LeStringInputCustomEvent<{
    value: string;
    name: string;
    externalId: string;
  }>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Whether the input is read-only
          * @default false
         */
        "readonly"?: boolean;
        /**
          * The type of the input (text, email, password, etc.)
          * @default 'text'
         */
        "type"?: 'text' | 'email' | 'password' | 'tel' | 'url';
        /**
          * The value of the input
         */
        "value"?: string;
    }
    /**
     * A tag/chip component for displaying labels with optional dismiss functionality.
     * @cmsEditable false
     * @cmsCategory Form
     * @example Basic tag
     * ```html
     * <le-tag label="JavaScript"></le-tag>
     * ```
     * @example Dismissible tag
     * ```html
     * <le-tag label="Remove me" dismissible></le-tag>
     * ```
     * @example With icon
     * ```html
     * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
     * ```
     * @example Different sizes
     * ```html
     * <le-tag label="Small" size="small"></le-tag>
     * <le-tag label="Medium" size="medium"></le-tag>
     * <le-tag label="Large" size="large"></le-tag>
     * ```
     * @example Different variants
     * ```html
     * <le-tag label="Default" variant="default"></le-tag>
     * <le-tag label="Primary" variant="primary"></le-tag>
     * <le-tag label="Success" variant="success"></le-tag>
     * <le-tag label="Warning" variant="warning"></le-tag>
     * <le-tag label="Danger" variant="danger"></le-tag>
     * ```
     */
    interface LeTag {
        /**
          * Whether the tag is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the tag can be dismissed (shows close button).
          * @default false
         */
        "dismissible"?: boolean;
        /**
          * Icon to display before the label. Can be an emoji, URL, or icon name.
         */
        "icon"?: string;
        /**
          * The text label to display in the tag.
         */
        "label"?: string;
        /**
          * Mode of the popover should be 'default' for internal use
         */
        "mode"?: 'default' | 'admin';
        /**
          * Emitted when the dismiss button is clicked.
         */
        "onLeDismiss"?: (event: LeTagCustomEvent<void>) => void;
        /**
          * The size of the tag.
          * @default 'medium'
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The visual variant of the tag.
          * @default 'default'
         */
        "variant"?: 'default' | 'primary' | 'success' | 'warning' | 'danger';
    }
    /**
     * A text component with rich text editing capabilities in admin mode.
     * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
     * and provides a Notion-like rich text editor in admin mode with formatting
     * toolbar for bold, italic, links, and paragraph type selection.
     * @cssprop --le-text-color - Text color
     * @cssprop --le-text-font-size - Font size
     * @cssprop --le-text-line-height - Line height
     * @cssprop --le-text-font-weight - Font weight
     * @csspart text - The text container element
     * @cmsEditable true
     * @cmsCategory Content
     */
    interface LeText {
        /**
          * Text alignment
          * @allowedValues left | center | right | justify
          * @default 'left'
         */
        "align"?: 'left' | 'center' | 'right' | 'justify';
        /**
          * Text color (CSS value or theme token)
         */
        "color"?: string;
        /**
          * Maximum number of lines before truncating (requires truncate=true)
         */
        "maxLines"?: number;
        /**
          * Whether the text should truncate with ellipsis
          * @default false
         */
        "truncate"?: boolean;
        /**
          * The semantic variant/type of text element
          * @allowedValues p | h1 | h2 | h3 | h4 | h5 | h6 | code | quote | label | small
          * @default 'p'
         */
        "variant"?: 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'code' | 'quote' | 'label' | 'small';
    }
    interface LeTurntable {
        /**
          * @default 'center'
         */
        "center"?: string;
        /**
          * @default 0
         */
        "value"?: number;
    }
    interface IntrinsicElements {
        "le-block-menu": LeBlockMenu;
        "le-box": LeBox;
        "le-button": LeButton;
        "le-card": LeCard;
        "le-checkbox": LeCheckbox;
        "le-combobox": LeCombobox;
        "le-component": LeComponent;
        "le-dropdown-base": LeDropdownBase;
        "le-editor-block": LeEditorBlock;
        "le-format-toolbar": LeFormatToolbar;
        "le-multiselect": LeMultiselect;
        "le-number-input": LeNumberInput;
        "le-popover": LePopover;
        "le-popup": LePopup;
        "le-rich-text-editor": LeRichTextEditor;
        "le-round-progress": LeRoundProgress;
        "le-select": LeSelect;
        "le-slot": LeSlot;
        "le-stack": LeStack;
        "le-string-input": LeStringInput;
        "le-tag": LeTag;
        "le-text": LeText;
        "le-turntable": LeTurntable;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Block menu (command palette) for the rich text editor.
             * Triggered by "/" at the start of a block or clicking the block type icon.
             * @cmsInternal true
             */
            "le-block-menu": LocalJSX.LeBlockMenu & JSXBase.HTMLAttributes<HTMLLeBlockMenuElement>;
            /**
             * A flexible box component for use as a flex item within le-stack.
             * `le-box` wraps content and provides flex item properties like grow, shrink,
             * basis, and self-alignment. It can also control its internal content alignment.
             * @cssprop --le-box-bg - Background color
             * @cssprop --le-box-padding - Padding inside the box
             * @cssprop --le-box-border-radius - Border radius
             * @csspart box - The main box container
             * @csspart content - The inner content wrapper
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-box": LocalJSX.LeBox & JSXBase.HTMLAttributes<HTMLLeBoxElement>;
            /**
             * A flexible button component with multiple variants and states.
             * @cssprop --le-button-bg - Button background color
             * @cssprop --le-button-color - Button text color
             * @cssprop --le-button-border-radius - Button border radius
             * @cssprop --le-button-padding-x - Button horizontal padding
             * @cssprop --le-button-padding-y - Button vertical padding
             * @csspart button - The native button element
             * @csspart content - The button content wrapper
             * @csspart icon-start - The start icon slot
             * @csspart icon-end - The end icon slot
             * @cmsEditable true
             * @cmsCategory Actions
             */
            "le-button": LocalJSX.LeButton & JSXBase.HTMLAttributes<HTMLLeButtonElement>;
            /**
             * A flexible card component with header, content, and footer slots.
             * The card uses le-slot wrappers for each slot area. In admin mode,
             * le-slot shows placeholders for CMS editing. In default mode,
             * le-slot acts as a transparent passthrough.
             * @cssprop --le-card-bg - Card background color
             * @cssprop --le-card-border-radius - Card border radius
             * @cssprop --le-card-shadow - Card box shadow
             * @cssprop --le-card-padding - Card content padding
             * @csspart card - The main card container
             * @csspart header - The card header section
             * @csspart content - The card content section
             * @csspart footer - The card footer section
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-card": LocalJSX.LeCard & JSXBase.HTMLAttributes<HTMLLeCardElement>;
            /**
             * A checkbox component with support for labels, descriptions, and external IDs.
             * @cssprop --le-checkbox-size - Size of the checkbox input
             * @cssprop --le-checkbox-color - Color of the checkbox when checked
             * @cssprop --le-checkbox-label-color - Color of the label text
             * @cssprop --le-checkbox-desc-color - Color of the description text
             */
            "le-checkbox": LocalJSX.LeCheckbox & JSXBase.HTMLAttributes<HTMLLeCheckboxElement>;
            /**
             * A combobox component with searchable dropdown.
             * Combines a text input with a dropdown list, allowing users to
             * filter options by typing or select from the list.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic combobox
             * ```html
             * <le-combobox
             * placeholder="Search..."
             * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
             * ></le-combobox>
             * ```
             * @example Allow custom values
             * ```html
             * <le-combobox
             * placeholder="Type or select..."
             * allow-custom
             * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
             * ></le-combobox>
             * ```
             */
            "le-combobox": LocalJSX.LeCombobox & JSXBase.HTMLAttributes<HTMLLeComboboxElement>;
            /**
             * Component wrapper for admin mode editing.
             * This component is used internally by other components to provide admin-mode
             * editing capabilities. It wraps the component's rendered output and shows
             * a settings popover for editing properties.
             * In default mode, it acts as a simple passthrough (display: contents).
             * In admin mode, it shows a border, component name header, and settings popover.
             * The host element is found automatically by traversing up through the shadow DOM.
             * Usage inside a component's render method:
             * ```tsx
             * render() {
             *   return (
             *     <le-component component="le-card">
             *       <Host>...</Host>
             *     </le-component>
             *   );
             * }
             * ```
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-component": LocalJSX.LeComponent & JSXBase.HTMLAttributes<HTMLLeComponentElement>;
            /**
             * Internal dropdown base component that provides shared functionality
             * for select, combobox, and multiselect components.
             * Wraps le-popover for positioning and provides:
             * - Option list rendering with groups
             * - Keyboard navigation (â†‘â†“, Enter, Escape, Home/End)
             * - Option filtering support
             * - Single and multi-select modes
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-dropdown-base": LocalJSX.LeDropdownBase & JSXBase.HTMLAttributes<HTMLLeDropdownBaseElement>;
            /**
             * Internal component representing a single block in the rich text editor.
             * @cmsInternal true
             */
            "le-editor-block": LocalJSX.LeEditorBlock & JSXBase.HTMLAttributes<HTMLLeEditorBlockElement>;
            /**
             * Floating format toolbar for text selection in the rich text editor.
             * Positions itself above the selection.
             * @cmsInternal true
             */
            "le-format-toolbar": LocalJSX.LeFormatToolbar & JSXBase.HTMLAttributes<HTMLLeFormatToolbarElement>;
            /**
             * A multiselect component for selecting multiple options.
             * Displays selected items as tags with optional search filtering.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic multiselect
             * ```html
             * <le-multiselect
             * placeholder="Select options..."
             * options='[{"label": "Red"}, {"label": "Green"}, {"label": "Blue"}]'
             * ></le-multiselect>
             * ```
             * @example With max selections
             * ```html
             * <le-multiselect
             * max-selections="3"
             * options='[{"label": "Option 1"}, {"label": "Option 2"}, {"label": "Option 3"}, {"label": "Option 4"}]'
             * ></le-multiselect>
             * ```
             * @example With search
             * ```html
             * <le-multiselect
             * searchable
             * placeholder="Search and select..."
             * options='[{"label": "Apple"}, {"label": "Banana"}, {"label": "Cherry"}]'
             * ></le-multiselect>
             * ```
             */
            "le-multiselect": LocalJSX.LeMultiselect & JSXBase.HTMLAttributes<HTMLLeMultiselectElement>;
            /**
             * A number input component with validation, keyboard controls, and custom spinners.
             * @cssprop --le-input-bg - Input background color
             * @cssprop --le-input-color - Input text color
             * @cssprop --le-input-border - Input border style
             * @cssprop --le-input-border-focus - Input border style when focused
             * @cssprop --le-input-border-error - Input border style when invalid
             * @cssprop --le-input-radius - Input border radius
             * @cssprop --le-input-padding - Input padding
             */
            "le-number-input": LocalJSX.LeNumberInput & JSXBase.HTMLAttributes<HTMLLeNumberInputElement>;
            /**
             * A popover component for displaying floating content.
             * Uses the native HTML Popover API for proper layering with dialogs
             * and other top-layer elements. Falls back gracefully in older browsers.
             * @csspart trigger - The popover trigger element
             * @csspart content - The popover content wrapper
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-popover": LocalJSX.LePopover & JSXBase.HTMLAttributes<HTMLLePopoverElement>;
            /**
             * A flexible popup/dialog component for alerts, confirms, prompts, and custom content.
             * Uses the native HTML <dialog> element for proper modal behavior, accessibility,
             * and focus management. Can be used declaratively in HTML or programmatically 
             * via leAlert(), leConfirm(), lePrompt().
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-popup": LocalJSX.LePopup & JSXBase.HTMLAttributes<HTMLLePopupElement>;
            /**
             * Rich text editor with block-based editing, similar to Notion.
             * Features:
             * - Block-based content structure (paragraphs, headings, lists, quotes, code, dividers)
             * - Markdown shortcuts (# for headings, - for lists, > for quotes, etc.)
             * - Inline formatting toolbar (bold, italic, underline, strikethrough, code, links)
             * - Block command menu triggered by /
             * - Drag and drop block reordering
             * - HTML and Markdown export
             * @cmsEditable true
             * @cmsCategory Content
             * @example Basic usage
             * ```html
             * <le-rich-text-editor placeholder="Start writing..."></le-rich-text-editor>
             * ```
             * @example With initial content
             * ```html
             * <le-rich-text-editor id="editor"></le-rich-text-editor>
             * <script>
             * const editor = document.getElementById('editor');
             * editor.setHtml('<h1>Hello</h1><p>World</p>');
             * </script>
             * ```
             */
            "le-rich-text-editor": LocalJSX.LeRichTextEditor & JSXBase.HTMLAttributes<HTMLLeRichTextEditorElement>;
            "le-round-progress": LocalJSX.LeRoundProgress & JSXBase.HTMLAttributes<HTMLLeRoundProgressElement>;
            /**
             * A select dropdown component for single selection.
             * @cmsEditable true
             * @cmsCategory Form
             * @example Basic select
             * ```html
             * <le-select
             * placeholder="Choose an option"
             * options='[{"label": "Option 1", "value": "1"}, {"label": "Option 2", "value": "2"}]'
             * ></le-select>
             * ```
             * @example With icons
             * ```html
             * <le-select
             * options='[
             * {"label": "Apple", "value": "apple", "iconStart": "ðŸŽ"},
             * {"label": "Banana", "value": "banana", "iconStart": "ðŸŒ"}
             * ]'
             * ></le-select>
             * ```
             * @example Grouped options
             * ```html
             * <le-select
             * options='[
             * {"label": "Apple", "value": "apple", "group": "Fruits"},
             * {"label": "Carrot", "value": "carrot", "group": "Vegetables"}
             * ]'
             * ></le-select>
             * ```
             */
            "le-select": LocalJSX.LeSelect & JSXBase.HTMLAttributes<HTMLLeSelectElement>;
            /**
             * Slot placeholder component for admin/CMS mode.
             * This component renders a visual placeholder for slots when in admin mode,
             * allowing CMS systems to show available drop zones for content or inline editing.
             * In non-admin mode, this component renders nothing and acts as a passthrough.
             * @cmsInternal true
             * @cmsCategory System
             */
            "le-slot": LocalJSX.LeSlot & JSXBase.HTMLAttributes<HTMLLeSlotElement>;
            /**
             * A flexible stack layout component using CSS flexbox.
             * `le-stack` arranges its children in a row (horizontal) or column (vertical)
             * with configurable spacing, alignment, and wrapping behavior. Perfect for
             * creating responsive layouts.
             * @cssprop --le-stack-gap - Gap between items (defaults to var(--le-space-md))
             * @csspart stack - The main stack container
             * @cmsEditable true
             * @cmsCategory Layout
             */
            "le-stack": LocalJSX.LeStack & JSXBase.HTMLAttributes<HTMLLeStackElement>;
            /**
             * A text input component with support for labels, descriptions, icons, and external IDs.
             * @cssprop --le-input-bg - Input background color
             * @cssprop --le-input-color - Input text color
             * @cssprop --le-input-border - Input border style
             * @cssprop --le-input-border-focus - Input border style when focused
             * @cssprop --le-input-radius - Input border radius
             * @cssprop --le-input-padding - Input padding
             */
            "le-string-input": LocalJSX.LeStringInput & JSXBase.HTMLAttributes<HTMLLeStringInputElement>;
            /**
             * A tag/chip component for displaying labels with optional dismiss functionality.
             * @cmsEditable false
             * @cmsCategory Form
             * @example Basic tag
             * ```html
             * <le-tag label="JavaScript"></le-tag>
             * ```
             * @example Dismissible tag
             * ```html
             * <le-tag label="Remove me" dismissible></le-tag>
             * ```
             * @example With icon
             * ```html
             * <le-tag label="Settings" icon="âš™ï¸"></le-tag>
             * ```
             * @example Different sizes
             * ```html
             * <le-tag label="Small" size="small"></le-tag>
             * <le-tag label="Medium" size="medium"></le-tag>
             * <le-tag label="Large" size="large"></le-tag>
             * ```
             * @example Different variants
             * ```html
             * <le-tag label="Default" variant="default"></le-tag>
             * <le-tag label="Primary" variant="primary"></le-tag>
             * <le-tag label="Success" variant="success"></le-tag>
             * <le-tag label="Warning" variant="warning"></le-tag>
             * <le-tag label="Danger" variant="danger"></le-tag>
             * ```
             */
            "le-tag": LocalJSX.LeTag & JSXBase.HTMLAttributes<HTMLLeTagElement>;
            /**
             * A text component with rich text editing capabilities in admin mode.
             * `le-text` renders semantic text elements (headings, paragraphs, code, quotes)
             * and provides a Notion-like rich text editor in admin mode with formatting
             * toolbar for bold, italic, links, and paragraph type selection.
             * @cssprop --le-text-color - Text color
             * @cssprop --le-text-font-size - Font size
             * @cssprop --le-text-line-height - Line height
             * @cssprop --le-text-font-weight - Font weight
             * @csspart text - The text container element
             * @cmsEditable true
             * @cmsCategory Content
             */
            "le-text": LocalJSX.LeText & JSXBase.HTMLAttributes<HTMLLeTextElement>;
            "le-turntable": LocalJSX.LeTurntable & JSXBase.HTMLAttributes<HTMLLeTurntableElement>;
        }
    }
}
